"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ec2 = require("@aws-cdk/aws-ec2");
const cdk = require("@aws-cdk/core");
const lib_1 = require("../lib");
/**
 * A load balancer that can host a VPC Endpoint Service.
 *
 * Why do this instead of using the NetworkLoadBalancer construct? aws-route53
 * cannot depend on aws-elasticloadbalancingv2 because aws-elasticloadbalancingv2
 * already takes a dependency on aws-route53.
 */
class DummyEndpointLoadBalancer {
    constructor(scope, id, vpc) {
        const lb = new cdk.CfnResource(scope, id, {
            type: 'AWS::ElasticLoadBalancingV2::LoadBalancer',
            properties: {
                Type: 'network',
                Name: 'mylb',
                Scheme: 'internal',
                Subnets: [vpc.privateSubnets[0].subnetId],
            },
        });
        this.loadBalancerArn = lb.ref;
    }
}
const app = new cdk.App();
const stack = new cdk.Stack(app, 'aws-cdk-vpc-endpoint-dns-integ');
const vpc = new ec2.Vpc(stack, 'VPC');
const nlb = new DummyEndpointLoadBalancer(stack, 'mylb', vpc);
const vpces = new ec2.VpcEndpointService(stack, 'VPCES', {
    vpcEndpointServiceLoadBalancers: [nlb],
});
const zone = new lib_1.PublicHostedZone(stack, 'PHZ', {
    zoneName: 'aws-cdk.dev',
});
new lib_1.VpcEndpointServiceDomainName(stack, 'EndpointDomain', {
    endpointService: vpces,
    domainName: 'my-stuff.aws-cdk.dev',
    publicHostedZone: zone,
});
app.synth();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZWcudnBjLWVuZHBvaW50LXNlcnZpY2UtZG9tYWluLW5hbWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJpbnRlZy52cGMtZW5kcG9pbnQtc2VydmljZS1kb21haW4tbmFtZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFFckMsZ0NBQXdFO0FBRXhFOzs7Ozs7R0FNRztBQUNILE1BQU0seUJBQXlCO0lBSzdCLFlBQVksS0FBZ0IsRUFBRSxFQUFVLEVBQUUsR0FBWTtRQUNwRCxNQUFNLEVBQUUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxXQUFXLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRTtZQUN4QyxJQUFJLEVBQUUsMkNBQTJDO1lBQ2pELFVBQVUsRUFBRTtnQkFDVixJQUFJLEVBQUUsU0FBUztnQkFDZixJQUFJLEVBQUUsTUFBTTtnQkFDWixNQUFNLEVBQUUsVUFBVTtnQkFDbEIsT0FBTyxFQUFFLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7YUFDMUM7U0FDRixDQUFDLENBQUM7UUFDSCxJQUFJLENBQUMsZUFBZSxHQUFHLEVBQUUsQ0FBQyxHQUFHLENBQUM7S0FDL0I7Q0FDRjtBQUVELE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO0FBQzFCLE1BQU0sS0FBSyxHQUFHLElBQUksR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsZ0NBQWdDLENBQUMsQ0FBQztBQUNuRSxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3RDLE1BQU0sR0FBRyxHQUFHLElBQUkseUJBQXlCLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxHQUFHLENBQUMsQ0FBQztBQUM5RCxNQUFNLEtBQUssR0FBRyxJQUFJLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsT0FBTyxFQUFFO0lBQ3ZELCtCQUErQixFQUFFLENBQUMsR0FBRyxDQUFDO0NBQ3ZDLENBQUMsQ0FBQztBQUNILE1BQU0sSUFBSSxHQUFHLElBQUksc0JBQWdCLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBRTtJQUM5QyxRQUFRLEVBQUUsYUFBYTtDQUN4QixDQUFDLENBQUM7QUFDSCxJQUFJLGtDQUE0QixDQUFDLEtBQUssRUFBRSxnQkFBZ0IsRUFBRTtJQUN4RCxlQUFlLEVBQUUsS0FBSztJQUN0QixVQUFVLEVBQUUsc0JBQXNCO0lBQ2xDLGdCQUFnQixFQUFFLElBQUk7Q0FDdkIsQ0FBQyxDQUFDO0FBRUgsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZWMyIGZyb20gJ0Bhd3MtY2RrL2F3cy1lYzInO1xuaW1wb3J0ICogYXMgY2RrIGZyb20gJ0Bhd3MtY2RrL2NvcmUnO1xuaW1wb3J0IHsgQ29uc3RydWN0IH0gZnJvbSAnY29uc3RydWN0cyc7XG5pbXBvcnQgeyBQdWJsaWNIb3N0ZWRab25lLCBWcGNFbmRwb2ludFNlcnZpY2VEb21haW5OYW1lIH0gZnJvbSAnLi4vbGliJztcblxuLyoqXG4gKiBBIGxvYWQgYmFsYW5jZXIgdGhhdCBjYW4gaG9zdCBhIFZQQyBFbmRwb2ludCBTZXJ2aWNlLlxuICpcbiAqIFdoeSBkbyB0aGlzIGluc3RlYWQgb2YgdXNpbmcgdGhlIE5ldHdvcmtMb2FkQmFsYW5jZXIgY29uc3RydWN0PyBhd3Mtcm91dGU1M1xuICogY2Fubm90IGRlcGVuZCBvbiBhd3MtZWxhc3RpY2xvYWRiYWxhbmNpbmd2MiBiZWNhdXNlIGF3cy1lbGFzdGljbG9hZGJhbGFuY2luZ3YyXG4gKiBhbHJlYWR5IHRha2VzIGEgZGVwZW5kZW5jeSBvbiBhd3Mtcm91dGU1My5cbiAqL1xuY2xhc3MgRHVtbXlFbmRwb2ludExvYWRCYWxhbmNlciBpbXBsZW1lbnRzIGVjMi5JVnBjRW5kcG9pbnRTZXJ2aWNlTG9hZEJhbGFuY2VyIHtcbiAgLyoqXG4gICAqIFRoZSBBUk4gb2YgdGhlIGxvYWQgYmFsYW5jZXIgdGhhdCBob3N0cyB0aGUgVlBDIEVuZHBvaW50IFNlcnZpY2VcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBsb2FkQmFsYW5jZXJBcm46IHN0cmluZztcbiAgY29uc3RydWN0b3Ioc2NvcGU6IENvbnN0cnVjdCwgaWQ6IHN0cmluZywgdnBjOiBlYzIuVnBjKSB7XG4gICAgY29uc3QgbGIgPSBuZXcgY2RrLkNmblJlc291cmNlKHNjb3BlLCBpZCwge1xuICAgICAgdHlwZTogJ0FXUzo6RWxhc3RpY0xvYWRCYWxhbmNpbmdWMjo6TG9hZEJhbGFuY2VyJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgVHlwZTogJ25ldHdvcmsnLFxuICAgICAgICBOYW1lOiAnbXlsYicsXG4gICAgICAgIFNjaGVtZTogJ2ludGVybmFsJyxcbiAgICAgICAgU3VibmV0czogW3ZwYy5wcml2YXRlU3VibmV0c1swXS5zdWJuZXRJZF0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMubG9hZEJhbGFuY2VyQXJuID0gbGIucmVmO1xuICB9XG59XG5cbmNvbnN0IGFwcCA9IG5ldyBjZGsuQXBwKCk7XG5jb25zdCBzdGFjayA9IG5ldyBjZGsuU3RhY2soYXBwLCAnYXdzLWNkay12cGMtZW5kcG9pbnQtZG5zLWludGVnJyk7XG5jb25zdCB2cGMgPSBuZXcgZWMyLlZwYyhzdGFjaywgJ1ZQQycpO1xuY29uc3QgbmxiID0gbmV3IER1bW15RW5kcG9pbnRMb2FkQmFsYW5jZXIoc3RhY2ssICdteWxiJywgdnBjKTtcbmNvbnN0IHZwY2VzID0gbmV3IGVjMi5WcGNFbmRwb2ludFNlcnZpY2Uoc3RhY2ssICdWUENFUycsIHtcbiAgdnBjRW5kcG9pbnRTZXJ2aWNlTG9hZEJhbGFuY2VyczogW25sYl0sXG59KTtcbmNvbnN0IHpvbmUgPSBuZXcgUHVibGljSG9zdGVkWm9uZShzdGFjaywgJ1BIWicsIHtcbiAgem9uZU5hbWU6ICdhd3MtY2RrLmRldicsXG59KTtcbm5ldyBWcGNFbmRwb2ludFNlcnZpY2VEb21haW5OYW1lKHN0YWNrLCAnRW5kcG9pbnREb21haW4nLCB7XG4gIGVuZHBvaW50U2VydmljZTogdnBjZXMsXG4gIGRvbWFpbk5hbWU6ICdteS1zdHVmZi5hd3MtY2RrLmRldicsXG4gIHB1YmxpY0hvc3RlZFpvbmU6IHpvbmUsXG59KTtcblxuYXBwLnN5bnRoKCk7XG4iXX0=