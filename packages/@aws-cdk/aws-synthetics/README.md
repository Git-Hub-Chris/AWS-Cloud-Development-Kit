## Amazon CloudWatch Synthetics Construct Library

<!--BEGIN STABILITY BANNER-->
---

![cfn-resources: Stable](https://img.shields.io/badge/cfn--resources-stable-success.svg?style=for-the-badge)

> All classes with the `Cfn` prefix in this module ([CFN Resources](https://docs.aws.amazon.com/cdk/latest/guide/constructs.html#constructs_lib)) are always stable and safe to use.

![cdk-constructs: Experimental](https://img.shields.io/badge/cdk--constructs-experimental-important.svg?style=for-the-badge)

> The APIs of higher level constructs in this module are experimental and under active development. They are subject to non-backward compatible changes or removal in any future version. These are not subject to the [Semantic Versioning](https://semver.org/) model and breaking changes will be announced in the release notes. This means that while you may use them, you may need to update your source code when upgrading to a newer version of this package.

---
<!--END STABILITY BANNER-->

Amazon CloudWatch Synthetics allow you to monitor your application by generating **synthetic** traffic. The traffic is generated by a **canary**. A canary is a configurable scripts that run on a schedule. You configure the canary script to follow the same routes and perform the same actions as a customer, which allows you to continually verify your customer experience even when you don't have any customer traffic on your applications.

## Canary

To illustrate how to use a canary, assume your application defines the following endpoint:

```bash
curl https://api.awsomesite.com/user/books/topbook/
The Hitchhikers Guide to the Galaxy

```

The bellow code defines a canary that will hit the `books/topbook` endpoint every 5 minutes:

```ts
const canary = new Canary(this, 'MyCanary', {
  name: 'mycanary'
  schedule: Schedule.Rate(Duration.minutes(1)),
  handler: 'index.handler',
  code: synth.Code.fromInline(
    `const https = require('https');
     var synthetics = require('Synthetics');
     const log = require('SyntheticsLogger');
  
     exports.handler = async function () {
      const requestOptions = {"hostname":"api.awsomesite.com","method":"","path":"/user/books/topbook/","port":443}
      let req = https.request(requestOptions);
      req.on('response', (res) => {
        log.info()
      });
     }`
    )
});
```

The canary will automatically produce a CloudWatch Dashboard:

![UI Screenshot](images/ui-screenshot-1.png)

### Alarms

You can configure a CloudWatch Alarm on canary metrics. Metrics are emitted by CloudWatch automatically and can be accessed by the following APIs:
- `canary.metricSuccessPercent()`
- `canary.metricDuration()`
- `canary.metricFailed()`

To configure an alarm use the `addAlarm()` method:
```ts

canary.addAlarm('CanaryAlarm', {
  metric: canary.metricSuccessPercent(),
  evaluationPeriods: 2,
  threshold: 90,
  comparisonOperator: cloudwatch.ComparisonOperator.LESS_THAN_THRESHOLD,
})
```

### Code

As your application becomes more complex you may want a canary which execute code that requires multiple files and/or dependencies, to include code from a local directory, use the `Code.fromAsset()` method:

```ts
const canary = new synth.Canary(this,'mycanary',{
  name: 'mycanary'
  schedule: Schedule.Rate(Duration.minutes(1)),
  handler: 'index.handler',
  code: synth.Code.fromAsset('./scripts'),
});
```

You can specify a zip file or a directory, if you specify a directory the CDK will zip it for you. You can read more about the `assets` mechanism [here]().

Alternatively you can reference a zip file from an S3 bucket:

```ts
const canary = new synth.Canary(this,'mycanary',{
  name: 'mycanary'
  schedule: Schedule.Rate(Duration.minutes(1)),
  handler: 'index.handler',
  code: synth.Code.fromBucket(bucket, key[, objectVersion]),
});
```


### Discussion + Future Work

- Modeling the `Schedule` property

  - Currently the Canary L1 takes a mandatory `Schedule` property that is an object with `DurationInSeconds` and `Expression` as sub-properties. `DurationInSeconds` specifies how long the canary should be active for and `Expression` defines how often the canary runs. I propose the L2 extracts `DurationInSeconds` from `Schedule` as `lifetime`. `Schedule` can be implemented in a similar fashion to autoscaling by exposing a static `rate(Duration)` method.
  
- `Code.fromAsset()` path

  - The issue is that the Canary resource requires imported code to have the directory structure `nodejs/node_modules`. This causes pain for customers because this requirement is unclear and dissimilar to lambda (the other common `fromAsset()` implementation). Currently the API will throw an error if the directory structure is not there. Ideally this implementation evolves to one of the following options:
    - The API will copy the files and append the `nodejs/node_modules` structure if it is missing at `synth` time. 
    - The API will add the `nodejs/node_modules` prefix at `build` time by modifying how `Asset` publishes directories. However, this implementation could alter how `assetHash` currently works.
