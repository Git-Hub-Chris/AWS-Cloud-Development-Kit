"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const iam = require("@aws-cdk/aws-iam");
const cdk = require("@aws-cdk/core");
const cx_api_1 = require("@aws-cdk/cx-api");
const lambda = require("../lib");
const app = new cdk.App();
const stack = new cdk.Stack(app, 'aws-cdk-lambda-pce-1');
const lambdaCode = 'exports.handler =  async function(event, context) { ' +
    'console.log("Hello from CDK! with #type# Provisioned Concurrent Exec!");}';
const pce = 5;
// Integration test for provisioned concurrent execution via Alias
const fn = new lambda.Function(stack, 'MyLambdaAliasPCE', {
    code: new lambda.InlineCode(lambdaCode.replace('#type#', 'Alias')),
    handler: 'index.handler',
    runtime: lambda.Runtime.NODEJS_14_X,
});
fn.addToRolePolicy(new iam.PolicyStatement({
    resources: ['*'],
    actions: ['*'],
}));
const version = fn.currentVersion;
const alias = new lambda.Alias(stack, 'Alias', {
    aliasName: 'prod',
    version,
    provisionedConcurrentExecutions: pce,
});
alias.addPermission('AliasPermission', {
    principal: new iam.ServicePrincipal('cloudformation.amazonaws.com'),
});
// Integration test for provisioned concurrent execution via Version
const fnVersionPCE = new lambda.Function(stack, 'MyLambdaVersionPCE', {
    code: new lambda.InlineCode(lambdaCode.replace('#type#', 'Version')),
    handler: 'index.handler',
    runtime: lambda.Runtime.NODEJS_14_X,
    currentVersionOptions: {
        provisionedConcurrentExecutions: pce,
    },
});
fnVersionPCE.addToRolePolicy(new iam.PolicyStatement({
    resources: ['*'],
    actions: ['*'],
}));
const version2 = fnVersionPCE.currentVersion;
const alias2 = new lambda.Alias(stack, 'Alias2', {
    aliasName: 'prod',
    version: version2,
});
alias2.addPermission('AliasPermission2', {
    principal: new iam.ServicePrincipal('cloudformation.amazonaws.com'),
});
// Changes the function description when the feature flag is present
// to validate the changed function hash.
cdk.Aspects.of(stack).add(new lambda.FunctionVersionUpgrade(cx_api_1.LAMBDA_RECOGNIZE_LAYER_VERSION));
app.synth();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZWcubGFtYmRhLnByb3YuY29uY3VycmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImludGVnLmxhbWJkYS5wcm92LmNvbmN1cnJlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx3Q0FBd0M7QUFDeEMscUNBQXFDO0FBQ3JDLDRDQUFpRTtBQUNqRSxpQ0FBaUM7QUFFakMsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxFQUFFLENBQUM7QUFFMUIsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0FBRXpELE1BQU0sVUFBVSxHQUFHLHNEQUFzRDtJQUN0RCwyRUFBMkUsQ0FBQztBQUUvRixNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFFZCxrRUFBa0U7QUFDbEUsTUFBTSxFQUFFLEdBQUcsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxrQkFBa0IsRUFBRTtJQUN4RCxJQUFJLEVBQUUsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xFLE9BQU8sRUFBRSxlQUFlO0lBQ3hCLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7Q0FDcEMsQ0FBQyxDQUFDO0FBRUgsRUFBRSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxlQUFlLENBQUM7SUFDekMsU0FBUyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ2hCLE9BQU8sRUFBRSxDQUFDLEdBQUcsQ0FBQztDQUNmLENBQUMsQ0FBQyxDQUFDO0FBRUosTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDLGNBQWMsQ0FBQztBQUVsQyxNQUFNLEtBQUssR0FBRyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRTtJQUM3QyxTQUFTLEVBQUUsTUFBTTtJQUNqQixPQUFPO0lBQ1AsK0JBQStCLEVBQUUsR0FBRztDQUNyQyxDQUFDLENBQUM7QUFFSCxLQUFLLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFO0lBQ3JDLFNBQVMsRUFBRSxJQUFJLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyw4QkFBOEIsQ0FBQztDQUNwRSxDQUFDLENBQUM7QUFFSCxvRUFBb0U7QUFDcEUsTUFBTSxZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxvQkFBb0IsRUFBRTtJQUNwRSxJQUFJLEVBQUUsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ3BFLE9BQU8sRUFBRSxlQUFlO0lBQ3hCLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLFdBQVc7SUFDbkMscUJBQXFCLEVBQUU7UUFDckIsK0JBQStCLEVBQUUsR0FBRztLQUNyQztDQUNGLENBQUMsQ0FBQztBQUVILFlBQVksQ0FBQyxlQUFlLENBQUMsSUFBSSxHQUFHLENBQUMsZUFBZSxDQUFDO0lBQ25ELFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUNoQixPQUFPLEVBQUUsQ0FBQyxHQUFHLENBQUM7Q0FDZixDQUFDLENBQUMsQ0FBQztBQUVKLE1BQU0sUUFBUSxHQUFHLFlBQVksQ0FBQyxjQUFjLENBQUM7QUFFN0MsTUFBTSxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUU7SUFDL0MsU0FBUyxFQUFFLE1BQU07SUFDakIsT0FBTyxFQUFFLFFBQVE7Q0FDbEIsQ0FBQyxDQUFDO0FBRUgsTUFBTSxDQUFDLGFBQWEsQ0FBQyxrQkFBa0IsRUFBRTtJQUN2QyxTQUFTLEVBQUUsSUFBSSxHQUFHLENBQUMsZ0JBQWdCLENBQUMsOEJBQThCLENBQUM7Q0FDcEUsQ0FBQyxDQUFDO0FBRUgsb0VBQW9FO0FBQ3BFLHlDQUF5QztBQUN6QyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxNQUFNLENBQUMsc0JBQXNCLENBQUMsdUNBQThCLENBQUMsQ0FBQyxDQUFDO0FBRTdGLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGlhbSBmcm9tICdAYXdzLWNkay9hd3MtaWFtJztcbmltcG9ydCAqIGFzIGNkayBmcm9tICdAYXdzLWNkay9jb3JlJztcbmltcG9ydCB7IExBTUJEQV9SRUNPR05JWkVfTEFZRVJfVkVSU0lPTiB9IGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBsYW1iZGEgZnJvbSAnLi4vbGliJztcblxuY29uc3QgYXBwID0gbmV3IGNkay5BcHAoKTtcblxuY29uc3Qgc3RhY2sgPSBuZXcgY2RrLlN0YWNrKGFwcCwgJ2F3cy1jZGstbGFtYmRhLXBjZS0xJyk7XG5cbmNvbnN0IGxhbWJkYUNvZGUgPSAnZXhwb3J0cy5oYW5kbGVyID0gIGFzeW5jIGZ1bmN0aW9uKGV2ZW50LCBjb250ZXh0KSB7ICcgK1xuICAgICAgICAgICAgICAgICAgICdjb25zb2xlLmxvZyhcIkhlbGxvIGZyb20gQ0RLISB3aXRoICN0eXBlIyBQcm92aXNpb25lZCBDb25jdXJyZW50IEV4ZWMhXCIpO30nO1xuXG5jb25zdCBwY2UgPSA1O1xuXG4vLyBJbnRlZ3JhdGlvbiB0ZXN0IGZvciBwcm92aXNpb25lZCBjb25jdXJyZW50IGV4ZWN1dGlvbiB2aWEgQWxpYXNcbmNvbnN0IGZuID0gbmV3IGxhbWJkYS5GdW5jdGlvbihzdGFjaywgJ015TGFtYmRhQWxpYXNQQ0UnLCB7XG4gIGNvZGU6IG5ldyBsYW1iZGEuSW5saW5lQ29kZShsYW1iZGFDb2RlLnJlcGxhY2UoJyN0eXBlIycsICdBbGlhcycpKSxcbiAgaGFuZGxlcjogJ2luZGV4LmhhbmRsZXInLFxuICBydW50aW1lOiBsYW1iZGEuUnVudGltZS5OT0RFSlNfMTRfWCxcbn0pO1xuXG5mbi5hZGRUb1JvbGVQb2xpY3kobmV3IGlhbS5Qb2xpY3lTdGF0ZW1lbnQoe1xuICByZXNvdXJjZXM6IFsnKiddLFxuICBhY3Rpb25zOiBbJyonXSxcbn0pKTtcblxuY29uc3QgdmVyc2lvbiA9IGZuLmN1cnJlbnRWZXJzaW9uO1xuXG5jb25zdCBhbGlhcyA9IG5ldyBsYW1iZGEuQWxpYXMoc3RhY2ssICdBbGlhcycsIHtcbiAgYWxpYXNOYW1lOiAncHJvZCcsXG4gIHZlcnNpb24sXG4gIHByb3Zpc2lvbmVkQ29uY3VycmVudEV4ZWN1dGlvbnM6IHBjZSxcbn0pO1xuXG5hbGlhcy5hZGRQZXJtaXNzaW9uKCdBbGlhc1Blcm1pc3Npb24nLCB7XG4gIHByaW5jaXBhbDogbmV3IGlhbS5TZXJ2aWNlUHJpbmNpcGFsKCdjbG91ZGZvcm1hdGlvbi5hbWF6b25hd3MuY29tJyksXG59KTtcblxuLy8gSW50ZWdyYXRpb24gdGVzdCBmb3IgcHJvdmlzaW9uZWQgY29uY3VycmVudCBleGVjdXRpb24gdmlhIFZlcnNpb25cbmNvbnN0IGZuVmVyc2lvblBDRSA9IG5ldyBsYW1iZGEuRnVuY3Rpb24oc3RhY2ssICdNeUxhbWJkYVZlcnNpb25QQ0UnLCB7XG4gIGNvZGU6IG5ldyBsYW1iZGEuSW5saW5lQ29kZShsYW1iZGFDb2RlLnJlcGxhY2UoJyN0eXBlIycsICdWZXJzaW9uJykpLFxuICBoYW5kbGVyOiAnaW5kZXguaGFuZGxlcicsXG4gIHJ1bnRpbWU6IGxhbWJkYS5SdW50aW1lLk5PREVKU18xNF9YLFxuICBjdXJyZW50VmVyc2lvbk9wdGlvbnM6IHtcbiAgICBwcm92aXNpb25lZENvbmN1cnJlbnRFeGVjdXRpb25zOiBwY2UsXG4gIH0sXG59KTtcblxuZm5WZXJzaW9uUENFLmFkZFRvUm9sZVBvbGljeShuZXcgaWFtLlBvbGljeVN0YXRlbWVudCh7XG4gIHJlc291cmNlczogWycqJ10sXG4gIGFjdGlvbnM6IFsnKiddLFxufSkpO1xuXG5jb25zdCB2ZXJzaW9uMiA9IGZuVmVyc2lvblBDRS5jdXJyZW50VmVyc2lvbjtcblxuY29uc3QgYWxpYXMyID0gbmV3IGxhbWJkYS5BbGlhcyhzdGFjaywgJ0FsaWFzMicsIHtcbiAgYWxpYXNOYW1lOiAncHJvZCcsXG4gIHZlcnNpb246IHZlcnNpb24yLFxufSk7XG5cbmFsaWFzMi5hZGRQZXJtaXNzaW9uKCdBbGlhc1Blcm1pc3Npb24yJywge1xuICBwcmluY2lwYWw6IG5ldyBpYW0uU2VydmljZVByaW5jaXBhbCgnY2xvdWRmb3JtYXRpb24uYW1hem9uYXdzLmNvbScpLFxufSk7XG5cbi8vIENoYW5nZXMgdGhlIGZ1bmN0aW9uIGRlc2NyaXB0aW9uIHdoZW4gdGhlIGZlYXR1cmUgZmxhZyBpcyBwcmVzZW50XG4vLyB0byB2YWxpZGF0ZSB0aGUgY2hhbmdlZCBmdW5jdGlvbiBoYXNoLlxuY2RrLkFzcGVjdHMub2Yoc3RhY2spLmFkZChuZXcgbGFtYmRhLkZ1bmN0aW9uVmVyc2lvblVwZ3JhZGUoTEFNQkRBX1JFQ09HTklaRV9MQVlFUl9WRVJTSU9OKSk7XG5cbmFwcC5zeW50aCgpO1xuIl19