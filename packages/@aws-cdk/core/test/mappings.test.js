"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const util_1 = require("./util");
const lib_1 = require("../lib");
describe('mappings', () => {
    test('mappings can be added as another type of entity, and mapping.findInMap can be used to get a token', () => {
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'MyMapping', {
            mapping: {
                TopLevelKey1: {
                    SecondLevelKey1: [1, 2, 3],
                    SecondLevelKey2: { Hello: 'World' },
                },
                TopLevelKey2: {
                    SecondLevelKey1: [99, 99, 99],
                },
            },
        });
        // findInMap can be used to take a reference
        new lib_1.CfnResource(stack, 'MyResource', {
            type: 'R',
            properties: {
                RefToValueInMap: mapping.findInMap('TopLevelKey1', 'SecondLevelKey1'),
            },
        });
        expect(() => mapping.findInMap('NotFoundTopLevel', 'NotFound')).toThrow('Mapping doesn\'t contain top-level key \'NotFoundTopLevel\'');
        expect(() => mapping.findInMap('TopLevelKey1', 'NotFound')).toThrow('Mapping doesn\'t contain second-level key \'NotFound\'');
        // set value can be used to set/modify a specific value
        mapping.setValue('TopLevelKey2', 'SecondLevelKey2', 'Hi');
        mapping.setValue('TopLevelKey1', 'SecondLevelKey1', [1, 2, 3, 4]);
        expect(util_1.toCloudFormation(stack)).toEqual({
            Mappings: {
                MyMapping: {
                    TopLevelKey1: {
                        SecondLevelKey1: [1, 2, 3, 4],
                        SecondLevelKey2: { Hello: 'World' },
                    },
                    TopLevelKey2: { SecondLevelKey1: [99, 99, 99], SecondLevelKey2: 'Hi' },
                },
            },
            Resources: {
                MyResource: {
                    Type: 'R',
                    Properties: {
                        RefToValueInMap: { 'Fn::FindInMap': ['MyMapping', 'TopLevelKey1', 'SecondLevelKey1'] },
                    },
                },
            },
        });
    });
    test('allow using unresolved tokens in find-in-map', () => {
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    instanceCount: 12,
                },
            },
        });
        const v1 = mapping.findInMap(lib_1.Aws.REGION, 'instanceCount');
        const v2 = lib_1.Fn.findInMap(mapping.logicalId, lib_1.Aws.REGION, 'instanceCount');
        const expected = { 'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'instanceCount'] };
        expect(stack.resolve(v1)).toEqual(expected);
        expect(stack.resolve(v2)).toEqual(expected);
        expect(util_1.toCloudFormation(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    instanceCount: 12,
                },
            },
        });
    });
    test('no validation if first key is token and second is a static string', () => {
        // GIVEN
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
        // WHEN
        const v = mapping.findInMap(lib_1.Aws.REGION, 'size');
        // THEN
        expect(stack.resolve(v)).toEqual({
            'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'size'],
        });
        expect(util_1.toCloudFormation(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
    });
    test('validate first key if it is a string and second is a token', () => {
        // GIVEN
        const stack = new lib_1.Stack();
        const mapping = new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
        // WHEN
        const v = mapping.findInMap(lib_1.Aws.REGION, 'size');
        // THEN
        expect(() => mapping.findInMap('not-found', 'size')).toThrow(/Mapping doesn't contain top-level key 'not-found'/);
        expect(stack.resolve(v)).toEqual({ 'Fn::FindInMap': ['mapping', { Ref: 'AWS::Region' }, 'size'] });
        expect(util_1.toCloudFormation(stack).Mappings).toEqual({
            mapping: {
                'us-east-1': {
                    size: 12,
                },
            },
        });
    });
    test('throws if mapping attribute name not alphanumeric', () => {
        const stack = new lib_1.Stack();
        expect(() => new lib_1.CfnMapping(stack, 'mapping', {
            mapping: {
                size: {
                    'us-east-1': 12,
                },
            },
        })).toThrowError(/Attribute name 'us-east-1' must contain only alphanumeric characters./);
    });
    test('using the value of a mapping in a different stack copies the mapping to the consuming stack', () => {
        const app = new lib_1.App();
        const creationStack = new lib_1.Stack(app, 'creationStack');
        const consumingStack = new lib_1.Stack(app, 'consumingStack');
        const mapping = new lib_1.CfnMapping(creationStack, 'MyMapping', {
            mapping: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        new lib_1.CfnOutput(consumingStack, 'Output', {
            value: mapping.findInMap('boo', 'bah'),
        });
        const v1 = mapping.findInMap('boo', 'bah');
        let v2 = lib_1.Fn.findInMap(mapping.logicalId, 'boo', 'bah');
        const creationStackExpected = { 'Fn::FindInMap': ['MyMapping', 'boo', 'bah'] };
        expect(creationStack.resolve(v1)).toEqual(creationStackExpected);
        expect(creationStack.resolve(v2)).toEqual(creationStackExpected);
        expect(util_1.toCloudFormation(creationStack).Mappings).toEqual({
            MyMapping: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        const mappingCopyLogicalId = 'MappingCopyMyMappingc843c23de60b3672d919ab3e4cb2c14042794164d8';
        v2 = lib_1.Fn.findInMap(mappingCopyLogicalId, 'boo', 'bah');
        const consumingStackExpected = { 'Fn::FindInMap': [mappingCopyLogicalId, 'boo', 'bah'] };
        expect(consumingStack.resolve(v1)).toEqual(consumingStackExpected);
        expect(consumingStack.resolve(v2)).toEqual(consumingStackExpected);
        expect(util_1.toCloudFormation(consumingStack).Mappings).toEqual({
            [mappingCopyLogicalId]: {
                boo: {
                    bah: 'foo',
                },
            },
        });
        expect(util_1.toCloudFormation(consumingStack).Outputs).toEqual({
            Output: {
                Value: {
                    'Fn::FindInMap': [
                        mappingCopyLogicalId,
                        'boo',
                        'bah',
                    ],
                },
            },
        });
    });
});
describe('lazy mapping', () => {
    let stack;
    let mapping;
    const backing = {
        TopLevelKey1: {
            SecondLevelKey1: [1, 2, 3],
            SecondLevelKey2: { Hello: 'World' },
        },
    };
    beforeEach(() => {
        stack = new lib_1.Stack();
        mapping = new lib_1.CfnMapping(stack, 'Lazy Mapping', {
            mapping: backing,
            lazy: true,
        });
    });
    it('does not create CfnMapping if findInMap keys can be resolved', () => {
        const retrievedValue = mapping.findInMap('TopLevelKey1', 'SecondLevelKey1');
        expect(stack.resolve(retrievedValue)).toStrictEqual([1, 2, 3]);
        expect(util_1.toCloudFormation(stack)).toStrictEqual({});
    });
    it('does not create CfnMapping if findInMap is not called', () => {
        expect(util_1.toCloudFormation(stack)).toStrictEqual({});
    });
    it('creates CfnMapping if top level key cannot be resolved', () => {
        const retrievedValue = mapping.findInMap(lib_1.Aws.REGION, 'SecondLevelKey1');
        expect(stack.resolve(retrievedValue)).toStrictEqual({ 'Fn::FindInMap': ['LazyMapping', { Ref: 'AWS::Region' }, 'SecondLevelKey1'] });
        expect(util_1.toCloudFormation(stack)).toStrictEqual({
            Mappings: {
                LazyMapping: backing,
            },
        });
    });
    it('creates CfnMapping if second level key cannot be resolved', () => {
        const retrievedValue = mapping.findInMap('TopLevelKey1', lib_1.Aws.REGION);
        expect(stack.resolve(retrievedValue)).toStrictEqual({ 'Fn::FindInMap': ['LazyMapping', 'TopLevelKey1', { Ref: 'AWS::Region' }] });
        expect(util_1.toCloudFormation(stack)).toStrictEqual({
            Mappings: {
                LazyMapping: backing,
            },
        });
    });
    it('throws if keys can be resolved but are not found in backing', () => {
        expect(() => mapping.findInMap('NonExistentKey', 'SecondLevelKey1'))
            .toThrowError(/Mapping doesn't contain top-level key .*/);
        expect(() => mapping.findInMap('TopLevelKey1', 'NonExistentKey'))
            .toThrowError(/Mapping doesn't contain second-level key .*/);
    });
});
describe('eager by default', () => {
    const backing = {
        TopLevelKey1: {
            SecondLevelKey1: [1, 2, 3],
            SecondLevelKey2: { Hello: 'World' },
        },
    };
    let app;
    let stack;
    let mapping;
    beforeEach(() => {
        app = new lib_1.App();
        stack = new lib_1.Stack(app, 'Stack');
        mapping = new lib_1.CfnMapping(stack, 'Lazy Mapping', {
            mapping: backing,
        });
    });
    it('emits warning if no findInMap called', () => {
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([{
                path: '/Stack/Lazy Mapping',
                message: 'Consider making this CfnMapping a lazy mapping by providing `lazy: true`: either no findInMap was called or every findInMap could be immediately resolved without using Fn::FindInMap',
            }]);
    });
    it('emits warning if every findInMap resolves immediately', () => {
        mapping.findInMap('TopLevelKey1', 'SecondLevelKey1');
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([{
                path: '/Stack/Lazy Mapping',
                message: 'Consider making this CfnMapping a lazy mapping by providing `lazy: true`: either no findInMap was called or every findInMap could be immediately resolved without using Fn::FindInMap',
            }]);
    });
    it('does not emit warning if a findInMap could not resolve immediately', () => {
        mapping.findInMap('TopLevelKey1', lib_1.Aws.REGION);
        const assembly = app.synth();
        expect(getInfoAnnotations(assembly)).toStrictEqual([]);
    });
});
function getInfoAnnotations(casm) {
    const result = new Array();
    for (const stack of Object.values(casm.manifest.artifacts ?? {})) {
        for (const [path, md] of Object.entries(stack.metadata ?? {})) {
            for (const x of md) {
                if (x.type === cloud_assembly_schema_1.ArtifactMetadataEntryType.INFO) {
                    result.push({ path, message: x.data });
                }
            }
        }
    }
    return result;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFwcGluZ3MudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1hcHBpbmdzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwRUFBMkU7QUFFM0UsaUNBQTBDO0FBQzFDLGdDQUFpRjtBQUVqRixRQUFRLENBQUMsVUFBVSxFQUFFLEdBQUcsRUFBRTtJQUN4QixJQUFJLENBQUMsbUdBQW1HLEVBQUUsR0FBRyxFQUFFO1FBQzdHLE1BQU0sS0FBSyxHQUFHLElBQUksV0FBSyxFQUFFLENBQUM7UUFDMUIsTUFBTSxPQUFPLEdBQUcsSUFBSSxnQkFBVSxDQUFDLEtBQUssRUFBRSxXQUFXLEVBQUU7WUFDakQsT0FBTyxFQUFFO2dCQUNQLFlBQVksRUFBRTtvQkFDWixlQUFlLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztvQkFDMUIsZUFBZSxFQUFFLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRTtpQkFDcEM7Z0JBQ0QsWUFBWSxFQUFFO29CQUNaLGVBQWUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDO2lCQUM5QjthQUNGO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsNENBQTRDO1FBQzVDLElBQUksaUJBQVcsQ0FBQyxLQUFLLEVBQUUsWUFBWSxFQUFFO1lBQ25DLElBQUksRUFBRSxHQUFHO1lBQ1QsVUFBVSxFQUFFO2dCQUNWLGVBQWUsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQzthQUN0RTtTQUNGLENBQUMsQ0FBQztRQUNILE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLDZEQUE2RCxDQUFDLENBQUM7UUFDdkksTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFLFVBQVUsQ0FBQyxDQUFD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QyxDQUFDO0lBQ3pELENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxTQUFTLGtCQUFrQixDQUFDLElBQW1CO0lBQzdDLE1BQU0sTUFBTSxHQUFHLElBQUksS0FBSyxFQUFxQyxDQUFDO0lBQzlELEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxFQUFFLENBQUMsRUFBRTtRQUNoRSxLQUFLLE1BQU0sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxFQUFFO1lBQzdELEtBQUssTUFBTSxDQUFDLElBQUksRUFBRSxFQUFFO2dCQUNsQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssaURBQXlCLENBQUMsSUFBSSxFQUFFO29CQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsSUFBYyxFQUFFLENBQUMsQ0FBQztpQkFDbEQ7YUFDRjtTQUNGO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQztBQUNoQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZSB9IGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgeyBDbG91ZEFzc2VtYmx5IH0gZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IHRvQ2xvdWRGb3JtYXRpb24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgQXBwLCBBd3MsIENmbk1hcHBpbmcsIENmblJlc291cmNlLCBDZm5PdXRwdXQsIEZuLCBTdGFjayB9IGZyb20gJy4uL2xpYic7XG5cbmRlc2NyaWJlKCdtYXBwaW5ncycsICgpID0+IHtcbiAgdGVzdCgnbWFwcGluZ3MgY2FuIGJlIGFkZGVkIGFzIGFub3RoZXIgdHlwZSBvZiBlbnRpdHksIGFuZCBtYXBwaW5nLmZpbmRJbk1hcCBjYW4gYmUgdXNlZCB0byBnZXQgYSB0b2tlbicsICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGNvbnN0IG1hcHBpbmcgPSBuZXcgQ2ZuTWFwcGluZyhzdGFjaywgJ015TWFwcGluZycsIHtcbiAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgVG9wTGV2ZWxLZXkxOiB7XG4gICAgICAgICAgU2Vjb25kTGV2ZWxLZXkxOiBbMSwgMiwgM10sXG4gICAgICAgICAgU2Vjb25kTGV2ZWxLZXkyOiB7IEhlbGxvOiAnV29ybGQnIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFRvcExldmVsS2V5Mjoge1xuICAgICAgICAgIFNlY29uZExldmVsS2V5MTogWzk5LCA5OSwgOTldLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIGZpbmRJbk1hcCBjYW4gYmUgdXNlZCB0byB0YWtlIGEgcmVmZXJlbmNlXG4gICAgbmV3IENmblJlc291cmNlKHN0YWNrLCAnTXlSZXNvdXJjZScsIHtcbiAgICAgIHR5cGU6ICdSJyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgUmVmVG9WYWx1ZUluTWFwOiBtYXBwaW5nLmZpbmRJbk1hcCgnVG9wTGV2ZWxLZXkxJywgJ1NlY29uZExldmVsS2V5MScpLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBleHBlY3QoKCkgPT4gbWFwcGluZy5maW5kSW5NYXAoJ05vdEZvdW5kVG9wTGV2ZWwnLCAnTm90Rm91bmQnKSkudG9UaHJvdygnTWFwcGluZyBkb2VzblxcJ3QgY29udGFpbiB0b3AtbGV2ZWwga2V5IFxcJ05vdEZvdW5kVG9wTGV2ZWxcXCcnKTtcbiAgICBleHBlY3QoKCkgPT4gbWFwcGluZy5maW5kSW5NYXAoJ1RvcExldmVsS2V5MScsICdOb3RGb3VuZCcpKS50b1Rocm93KCdNYXBwaW5nIGRvZXNuXFwndCBjb250YWluIHNlY29uZC1sZXZlbCBrZXkgXFwnTm90Rm91bmRcXCcnKTtcblxuICAgIC8vIHNldCB2YWx1ZSBjYW4gYmUgdXNlZCB0byBzZXQvbW9kaWZ5IGEgc3BlY2lmaWMgdmFsdWVcbiAgICBtYXBwaW5nLnNldFZhbHVlKCdUb3BMZXZlbEtleTInLCAnU2Vjb25kTGV2ZWxLZXkyJywgJ0hpJyk7XG4gICAgbWFwcGluZy5zZXRWYWx1ZSgnVG9wTGV2ZWxLZXkxJywgJ1NlY29uZExldmVsS2V5MScsIFsxLCAyLCAzLCA0XSk7XG5cbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykpLnRvRXF1YWwoe1xuICAgICAgTWFwcGluZ3M6XG4gICAgICB7XG4gICAgICAgIE15TWFwcGluZzpcbiAgICAgICAgIHtcbiAgICAgICAgICAgVG9wTGV2ZWxLZXkxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIFNlY29uZExldmVsS2V5MTogWzEsIDIsIDMsIDRdLFxuICAgICAgICAgICAgU2Vjb25kTGV2ZWxLZXkyOiB7IEhlbGxvOiAnV29ybGQnIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAgVG9wTGV2ZWxLZXkyOiB7IFNlY29uZExldmVsS2V5MTogWzk5LCA5OSwgOTldLCBTZWNvbmRMZXZlbEtleTI6ICdIaScgfSxcbiAgICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgUmVzb3VyY2VzOlxuICAgICAge1xuICAgICAgICBNeVJlc291cmNlOlxuICAgICAgICAge1xuICAgICAgICAgICBUeXBlOiAnUicsXG4gICAgICAgICAgIFByb3BlcnRpZXM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgUmVmVG9WYWx1ZUluTWFwOlxuICAgICAgICAgICB7ICdGbjo6RmluZEluTWFwJzogWydNeU1hcHBpbmcnLCAnVG9wTGV2ZWxLZXkxJywgJ1NlY29uZExldmVsS2V5MSddIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICB0ZXN0KCdhbGxvdyB1c2luZyB1bnJlc29sdmVkIHRva2VucyBpbiBmaW5kLWluLW1hcCcsICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuXG4gICAgY29uc3QgbWFwcGluZyA9IG5ldyBDZm5NYXBwaW5nKHN0YWNrLCAnbWFwcGluZycsIHtcbiAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgJ3VzLWVhc3QtMSc6IHtcbiAgICAgICAgICBpbnN0YW5jZUNvdW50OiAxMixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICBjb25zdCB2MSA9IG1hcHBpbmcuZmluZEluTWFwKEF3cy5SRUdJT04sICdpbnN0YW5jZUNvdW50Jyk7XG4gICAgY29uc3QgdjIgPSBGbi5maW5kSW5NYXAobWFwcGluZy5sb2dpY2FsSWQsIEF3cy5SRUdJT04sICdpbnN0YW5jZUNvdW50Jyk7XG5cbiAgICBjb25zdCBleHBlY3RlZCA9IHsgJ0ZuOjpGaW5kSW5NYXAnOiBbJ21hcHBpbmcnLCB7IFJlZjogJ0FXUzo6UmVnaW9uJyB9LCAnaW5zdGFuY2VDb3VudCddIH07XG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUodjEpKS50b0VxdWFsKGV4cGVjdGVkKTtcbiAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZSh2MikpLnRvRXF1YWwoZXhwZWN0ZWQpO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKHN0YWNrKS5NYXBwaW5ncykudG9FcXVhbCh7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgICd1cy1lYXN0LTEnOiB7XG4gICAgICAgICAgaW5zdGFuY2VDb3VudDogMTIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICB0ZXN0KCdubyB2YWxpZGF0aW9uIGlmIGZpcnN0IGtleSBpcyB0b2tlbiBhbmQgc2Vjb25kIGlzIGEgc3RhdGljIHN0cmluZycsICgpID0+IHtcbiAgICAvLyBHSVZFTlxuICAgIGNvbnN0IHN0YWNrID0gbmV3IFN0YWNrKCk7XG4gICAgY29uc3QgbWFwcGluZyA9IG5ldyBDZm5NYXBwaW5nKHN0YWNrLCAnbWFwcGluZycsIHtcbiAgICAgIG1hcHBpbmc6IHtcbiAgICAgICAgJ3VzLWVhc3QtMSc6IHtcbiAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICAvLyBXSEVOXG4gICAgY29uc3QgdiA9IG1hcHBpbmcuZmluZEluTWFwKEF3cy5SRUdJT04sICdzaXplJyk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUodikpLnRvRXF1YWwoe1xuICAgICAgJ0ZuOjpGaW5kSW5NYXAnOiBbJ21hcHBpbmcnLCB7IFJlZjogJ0FXUzo6UmVnaW9uJyB9LCAnc2l6ZSddLFxuICAgIH0pO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKHN0YWNrKS5NYXBwaW5ncykudG9FcXVhbCh7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgICd1cy1lYXN0LTEnOiB7XG4gICAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcblxuICB0ZXN0KCd2YWxpZGF0ZSBmaXJzdCBrZXkgaWYgaXQgaXMgYSBzdHJpbmcgYW5kIHNlY29uZCBpcyBhIHRva2VuJywgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgY29uc3Qgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICBjb25zdCBtYXBwaW5nID0gbmV3IENmbk1hcHBpbmcoc3RhY2ssICdtYXBwaW5nJywge1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICAndXMtZWFzdC0xJzoge1xuICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIC8vIFdIRU5cbiAgICBjb25zdCB2ID0gbWFwcGluZy5maW5kSW5NYXAoQXdzLlJFR0lPTiwgJ3NpemUnKTtcblxuICAgIC8vIFRIRU5cbiAgICBleHBlY3QoKCkgPT4gbWFwcGluZy5maW5kSW5NYXAoJ25vdC1mb3VuZCcsICdzaXplJykpLnRvVGhyb3coL01hcHBpbmcgZG9lc24ndCBjb250YWluIHRvcC1sZXZlbCBrZXkgJ25vdC1mb3VuZCcvKTtcbiAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZSh2KSkudG9FcXVhbCh7ICdGbjo6RmluZEluTWFwJzogWydtYXBwaW5nJywgeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgJ3NpemUnXSB9KTtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykuTWFwcGluZ3MpLnRvRXF1YWwoe1xuICAgICAgbWFwcGluZzoge1xuICAgICAgICAndXMtZWFzdC0xJzoge1xuICAgICAgICAgIHNpemU6IDEyLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgdGVzdCgndGhyb3dzIGlmIG1hcHBpbmcgYXR0cmlidXRlIG5hbWUgbm90IGFscGhhbnVtZXJpYycsICgpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIGV4cGVjdCgoKSA9PiBuZXcgQ2ZuTWFwcGluZyhzdGFjaywgJ21hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgIHNpemU6IHtcbiAgICAgICAgICAndXMtZWFzdC0xJzogMTIsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pKS50b1Rocm93RXJyb3IoL0F0dHJpYnV0ZSBuYW1lICd1cy1lYXN0LTEnIG11c3QgY29udGFpbiBvbmx5IGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLi8pO1xuICB9KTtcblxuICB0ZXN0KCd1c2luZyB0aGUgdmFsdWUgb2YgYSBtYXBwaW5nIGluIGEgZGlmZmVyZW50IHN0YWNrIGNvcGllcyB0aGUgbWFwcGluZyB0byB0aGUgY29uc3VtaW5nIHN0YWNrJywgKCkgPT4ge1xuICAgIGNvbnN0IGFwcCA9IG5ldyBBcHAoKTtcbiAgICBjb25zdCBjcmVhdGlvblN0YWNrID0gbmV3IFN0YWNrKGFwcCwgJ2NyZWF0aW9uU3RhY2snKTtcbiAgICBjb25zdCBjb25zdW1pbmdTdGFjayA9IG5ldyBTdGFjayhhcHAsICdjb25zdW1pbmdTdGFjaycpO1xuXG4gICAgY29uc3QgbWFwcGluZyA9IG5ldyBDZm5NYXBwaW5nKGNyZWF0aW9uU3RhY2ssICdNeU1hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiB7XG4gICAgICAgIGJvbzoge1xuICAgICAgICAgIGJhaDogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgbmV3IENmbk91dHB1dChjb25zdW1pbmdTdGFjaywgJ091dHB1dCcsIHtcbiAgICAgIHZhbHVlOiBtYXBwaW5nLmZpbmRJbk1hcCgnYm9vJywgJ2JhaCcpLFxuICAgIH0pO1xuXG4gICAgY29uc3QgdjEgPSBtYXBwaW5nLmZpbmRJbk1hcCgnYm9vJywgJ2JhaCcpO1xuICAgIGxldCB2MiA9IEZuLmZpbmRJbk1hcChtYXBwaW5nLmxvZ2ljYWxJZCwgJ2JvbycsICdiYWgnKTtcblxuICAgIGNvbnN0IGNyZWF0aW9uU3RhY2tFeHBlY3RlZCA9IHsgJ0ZuOjpGaW5kSW5NYXAnOiBbJ015TWFwcGluZycsICdib28nLCAnYmFoJ10gfTtcbiAgICBleHBlY3QoY3JlYXRpb25TdGFjay5yZXNvbHZlKHYxKSkudG9FcXVhbChjcmVhdGlvblN0YWNrRXhwZWN0ZWQpO1xuICAgIGV4cGVjdChjcmVhdGlvblN0YWNrLnJlc29sdmUodjIpKS50b0VxdWFsKGNyZWF0aW9uU3RhY2tFeHBlY3RlZCk7XG4gICAgZXhwZWN0KHRvQ2xvdWRGb3JtYXRpb24oY3JlYXRpb25TdGFjaykuTWFwcGluZ3MpLnRvRXF1YWwoe1xuICAgICAgTXlNYXBwaW5nOiB7XG4gICAgICAgIGJvbzoge1xuICAgICAgICAgIGJhaDogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgbWFwcGluZ0NvcHlMb2dpY2FsSWQgPSAnTWFwcGluZ0NvcHlNeU1hcHBpbmdjODQzYzIzZGU2MGIzNjcyZDkxOWFiM2U0Y2IyYzE0MDQyNzk0MTY0ZDgnO1xuICAgIHYyID0gRm4uZmluZEluTWFwKG1hcHBpbmdDb3B5TG9naWNhbElkLCAnYm9vJywgJ2JhaCcpO1xuICAgIGNvbnN0IGNvbnN1bWluZ1N0YWNrRXhwZWN0ZWQgPSB7ICdGbjo6RmluZEluTWFwJzogW21hcHBpbmdDb3B5TG9naWNhbElkLCAnYm9vJywgJ2JhaCddIH07XG5cbiAgICBleHBlY3QoY29uc3VtaW5nU3RhY2sucmVzb2x2ZSh2MSkpLnRvRXF1YWwoY29uc3VtaW5nU3RhY2tFeHBlY3RlZCk7XG4gICAgZXhwZWN0KGNvbnN1bWluZ1N0YWNrLnJlc29sdmUodjIpKS50b0VxdWFsKGNvbnN1bWluZ1N0YWNrRXhwZWN0ZWQpO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKGNvbnN1bWluZ1N0YWNrKS5NYXBwaW5ncykudG9FcXVhbCh7XG4gICAgICBbbWFwcGluZ0NvcHlMb2dpY2FsSWRdOiB7XG4gICAgICAgIGJvbzoge1xuICAgICAgICAgIGJhaDogJ2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKGNvbnN1bWluZ1N0YWNrKS5PdXRwdXRzKS50b0VxdWFsKHtcbiAgICAgIE91dHB1dDoge1xuICAgICAgICBWYWx1ZToge1xuICAgICAgICAgICdGbjo6RmluZEluTWFwJzogW1xuICAgICAgICAgICAgbWFwcGluZ0NvcHlMb2dpY2FsSWQsXG4gICAgICAgICAgICAnYm9vJyxcbiAgICAgICAgICAgICdiYWgnLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnbGF6eSBtYXBwaW5nJywgKCkgPT4ge1xuICBsZXQgc3RhY2s6IFN0YWNrO1xuICBsZXQgbWFwcGluZzogQ2ZuTWFwcGluZztcbiAgY29uc3QgYmFja2luZyA9IHtcbiAgICBUb3BMZXZlbEtleTE6IHtcbiAgICAgIFNlY29uZExldmVsS2V5MTogWzEsIDIsIDNdLFxuICAgICAgU2Vjb25kTGV2ZWxLZXkyOiB7IEhlbGxvOiAnV29ybGQnIH0sXG4gICAgfSxcbiAgfTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBzdGFjayA9IG5ldyBTdGFjaygpO1xuICAgIG1hcHBpbmcgPSBuZXcgQ2ZuTWFwcGluZyhzdGFjaywgJ0xhenkgTWFwcGluZycsIHtcbiAgICAgIG1hcHBpbmc6IGJhY2tpbmcsXG4gICAgICBsYXp5OiB0cnVlLFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnZG9lcyBub3QgY3JlYXRlIENmbk1hcHBpbmcgaWYgZmluZEluTWFwIGtleXMgY2FuIGJlIHJlc29sdmVkJywgKCkgPT4ge1xuICAgIGNvbnN0IHJldHJpZXZlZFZhbHVlID0gbWFwcGluZy5maW5kSW5NYXAoJ1RvcExldmVsS2V5MScsICdTZWNvbmRMZXZlbEtleTEnKTtcblxuICAgIGV4cGVjdChzdGFjay5yZXNvbHZlKHJldHJpZXZlZFZhbHVlKSkudG9TdHJpY3RFcXVhbChbMSwgMiwgM10pO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKHN0YWNrKSkudG9TdHJpY3RFcXVhbCh7fSk7XG4gIH0pO1xuXG4gIGl0KCdkb2VzIG5vdCBjcmVhdGUgQ2ZuTWFwcGluZyBpZiBmaW5kSW5NYXAgaXMgbm90IGNhbGxlZCcsICgpID0+IHtcbiAgICBleHBlY3QodG9DbG91ZEZvcm1hdGlvbihzdGFjaykpLnRvU3RyaWN0RXF1YWwoe30pO1xuICB9KTtcblxuICBpdCgnY3JlYXRlcyBDZm5NYXBwaW5nIGlmIHRvcCBsZXZlbCBrZXkgY2Fubm90IGJlIHJlc29sdmVkJywgKCkgPT4ge1xuICAgIGNvbnN0IHJldHJpZXZlZFZhbHVlID0gbWFwcGluZy5maW5kSW5NYXAoQXdzLlJFR0lPTiwgJ1NlY29uZExldmVsS2V5MScpO1xuXG4gICAgZXhwZWN0KHN0YWNrLnJlc29sdmUocmV0cmlldmVkVmFsdWUpKS50b1N0cmljdEVxdWFsKHsgJ0ZuOjpGaW5kSW5NYXAnOiBbJ0xhenlNYXBwaW5nJywgeyBSZWY6ICdBV1M6OlJlZ2lvbicgfSwgJ1NlY29uZExldmVsS2V5MSddIH0pO1xuICAgIGV4cGVjdCh0b0Nsb3VkRm9ybWF0aW9uKHN0YWNrKSkudG9TdHJpY3RFcXVhbCh7XG4gICAgICBNYXBwaW5nczoge1xuICAgICAgICBMYXp5TWFwcGluZzogYmFja2luZyxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdjcmVhdGVzIENmbk1hcHBpbmcgaWYgc2Vjb25kIGxldmVsIGtleSBjYW5ub3QgYmUgcmVzb2x2ZWQnLCAoKSA9PiB7XG4gICAgY29uc3QgcmV0cmlldmVkVmFsdWUgPSBtYXBwaW5nLmZpbmRJbk1hcCgnVG9wTGV2ZWxLZXkxJywgQXdzLlJFR0lPTik7XG5cbiAgICBleHBlY3Qoc3RhY2sucmVzb2x2ZShyZXRyaWV2ZWRWYWx1ZSkpLnRvU3RyaWN0RXF1YWwoeyAnRm46OkZpbmRJbk1hcCc6IFsnTGF6eU1hcHBpbmcnLCAnVG9wTGV2ZWxLZXkxJywgeyBSZWY6ICdBV1M6OlJlZ2lvbicgfV0gfSk7XG4gICAgZXhwZWN0KHRvQ2xvdWRGb3JtYXRpb24oc3RhY2spKS50b1N0cmljdEVxdWFsKHtcbiAgICAgIE1hcHBpbmdzOiB7XG4gICAgICAgIExhenlNYXBwaW5nOiBiYWNraW5nLFxuICAgICAgfSxcbiAgICB9KTtcbiAgfSk7XG5cbiAgaXQoJ3Rocm93cyBpZiBrZXlzIGNhbiBiZSByZXNvbHZlZCBidXQgYXJlIG5vdCBmb3VuZCBpbiBiYWNraW5nJywgKCkgPT4ge1xuICAgIGV4cGVjdCgoKSA9PiBtYXBwaW5nLmZpbmRJbk1hcCgnTm9uRXhpc3RlbnRLZXknLCAnU2Vjb25kTGV2ZWxLZXkxJykpXG4gICAgICAudG9UaHJvd0Vycm9yKC9NYXBwaW5nIGRvZXNuJ3QgY29udGFpbiB0b3AtbGV2ZWwga2V5IC4qLyk7XG4gICAgZXhwZWN0KCgpID0+IG1hcHBpbmcuZmluZEluTWFwKCdUb3BMZXZlbEtleTEnLCAnTm9uRXhpc3RlbnRLZXknKSlcbiAgICAgIC50b1Rocm93RXJyb3IoL01hcHBpbmcgZG9lc24ndCBjb250YWluIHNlY29uZC1sZXZlbCBrZXkgLiovKTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ2VhZ2VyIGJ5IGRlZmF1bHQnLCAoKSA9PiB7XG4gIGNvbnN0IGJhY2tpbmcgPSB7XG4gICAgVG9wTGV2ZWxLZXkxOiB7XG4gICAgICBTZWNvbmRMZXZlbEtleTE6IFsxLCAyLCAzXSxcbiAgICAgIFNlY29uZExldmVsS2V5MjogeyBIZWxsbzogJ1dvcmxkJyB9LFxuICAgIH0sXG4gIH07XG5cbiAgbGV0IGFwcDogQXBwO1xuICBsZXQgc3RhY2s6IFN0YWNrO1xuICBsZXQgbWFwcGluZzogQ2ZuTWFwcGluZztcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBhcHAgPSBuZXcgQXBwKCk7XG4gICAgc3RhY2sgPSBuZXcgU3RhY2soYXBwLCAnU3RhY2snKTtcbiAgICBtYXBwaW5nID0gbmV3IENmbk1hcHBpbmcoc3RhY2ssICdMYXp5IE1hcHBpbmcnLCB7XG4gICAgICBtYXBwaW5nOiBiYWNraW5nLFxuICAgIH0pO1xuICB9KTtcblxuICBpdCgnZW1pdHMgd2FybmluZyBpZiBubyBmaW5kSW5NYXAgY2FsbGVkJywgKCkgPT4ge1xuICAgIGNvbnN0IGFzc2VtYmx5ID0gYXBwLnN5bnRoKCk7XG5cbiAgICBleHBlY3QoZ2V0SW5mb0Fubm90YXRpb25zKGFzc2VtYmx5KSkudG9TdHJpY3RFcXVhbChbe1xuICAgICAgcGF0aDogJy9TdGFjay9MYXp5IE1hcHBpbmcnLFxuICAgICAgbWVzc2FnZTogJ0NvbnNpZGVyIG1ha2luZyB0aGlzIENmbk1hcHBpbmcgYSBsYXp5IG1hcHBpbmcgYnkgcHJvdmlkaW5nIGBsYXp5OiB0cnVlYDogZWl0aGVyIG5vIGZpbmRJbk1hcCB3YXMgY2FsbGVkIG9yIGV2ZXJ5IGZpbmRJbk1hcCBjb3VsZCBiZSBpbW1lZGlhdGVseSByZXNvbHZlZCB3aXRob3V0IHVzaW5nIEZuOjpGaW5kSW5NYXAnLFxuICAgIH1dKTtcbiAgfSk7XG5cbiAgaXQoJ2VtaXRzIHdhcm5pbmcgaWYgZXZlcnkgZmluZEluTWFwIHJlc29sdmVzIGltbWVkaWF0ZWx5JywgKCkgPT4ge1xuICAgIG1hcHBpbmcuZmluZEluTWFwKCdUb3BMZXZlbEtleTEnLCAnU2Vjb25kTGV2ZWxLZXkxJyk7XG5cbiAgICBjb25zdCBhc3NlbWJseSA9IGFwcC5zeW50aCgpO1xuXG4gICAgZXhwZWN0KGdldEluZm9Bbm5vdGF0aW9ucyhhc3NlbWJseSkpLnRvU3RyaWN0RXF1YWwoW3tcbiAgICAgIHBhdGg6ICcvU3RhY2svTGF6eSBNYXBwaW5nJyxcbiAgICAgIG1lc3NhZ2U6ICdDb25zaWRlciBtYWtpbmcgdGhpcyBDZm5NYXBwaW5nIGEgbGF6eSBtYXBwaW5nIGJ5IHByb3ZpZGluZyBgbGF6eTogdHJ1ZWA6IGVpdGhlciBubyBmaW5kSW5NYXAgd2FzIGNhbGxlZCBvciBldmVyeSBmaW5kSW5NYXAgY291bGQgYmUgaW1tZWRpYXRlbHkgcmVzb2x2ZWQgd2l0aG91dCB1c2luZyBGbjo6RmluZEluTWFwJyxcbiAgICB9XSk7XG4gIH0pO1xuXG4gIGl0KCdkb2VzIG5vdCBlbWl0IHdhcm5pbmcgaWYgYSBmaW5kSW5NYXAgY291bGQgbm90IHJlc29sdmUgaW1tZWRpYXRlbHknLCAoKSA9PiB7XG4gICAgbWFwcGluZy5maW5kSW5NYXAoJ1RvcExldmVsS2V5MScsIEF3cy5SRUdJT04pO1xuXG4gICAgY29uc3QgYXNzZW1ibHkgPSBhcHAuc3ludGgoKTtcblxuICAgIGV4cGVjdChnZXRJbmZvQW5ub3RhdGlvbnMoYXNzZW1ibHkpKS50b1N0cmljdEVxdWFsKFtdKTtcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gZ2V0SW5mb0Fubm90YXRpb25zKGNhc206IENsb3VkQXNzZW1ibHkpIHtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5PHsgcGF0aDogc3RyaW5nLCBtZXNzYWdlOiBzdHJpbmcgfT4oKTtcbiAgZm9yIChjb25zdCBzdGFjayBvZiBPYmplY3QudmFsdWVzKGNhc20ubWFuaWZlc3QuYXJ0aWZhY3RzID8/IHt9KSkge1xuICAgIGZvciAoY29uc3QgW3BhdGgsIG1kXSBvZiBPYmplY3QuZW50cmllcyhzdGFjay5tZXRhZGF0YSA/PyB7fSkpIHtcbiAgICAgIGZvciAoY29uc3QgeCBvZiBtZCkge1xuICAgICAgICBpZiAoeC50eXBlID09PSBBcnRpZmFjdE1ldGFkYXRhRW50cnlUeXBlLklORk8pIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh7IHBhdGgsIG1lc3NhZ2U6IHguZGF0YSBhcyBzdHJpbmcgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdfQ==