"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.attachCustomSynthesis = exports.App = void 0;
const jsiiDeprecationWarnings = require("../.warnings.jsii.js");
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const cxapi = require("@aws-cdk/cx-api");
const fs = require("fs-extra");
const private_context_1 = require("./private/private-context");
const synthesis_1 = require("./private/synthesis");
const stage_1 = require("./stage");
const APP_SYMBOL = Symbol.for('@aws-cdk/core.App');
/**
 * A construct which represents an entire CDK app. This construct is normally
 * the root of the construct tree.
 *
 * You would normally define an `App` instance in your program's entrypoint,
 * then define constructs where the app is used as the parent scope.
 *
 * After all the child constructs are defined within the app, you should call
 * `app.synth()` which will emit a "cloud assembly" from this app into the
 * directory specified by `outdir`. Cloud assemblies includes artifacts such as
 * CloudFormation templates and assets that are needed to deploy this app into
 * the AWS cloud.
 *
 * @see https://docs.aws.amazon.com/cdk/latest/guide/apps.html
 */
class App extends stage_1.Stage {
    /**
     * Checks if an object is an instance of the `App` class.
     * @returns `true` if `obj` is an `App`.
     * @param obj The object to evaluate
     */
    static isApp(obj) {
        return APP_SYMBOL in obj;
    }
    /**
     * Initializes a CDK application.
     * @param props initialization properties
     */
    constructor(props = {}) {
        super(undefined, '', {
            outdir: props.outdir ?? process.env[cxapi.OUTDIR_ENV],
        });
        try {
            jsiiDeprecationWarnings._aws_cdk_core_AppProps(props);
        }
        catch (error) {
            if (process.env.JSII_DEBUG !== "1" && error.name === "DeprecationError") {
                Error.captureStackTrace(error, App);
            }
            throw error;
        }
        Object.defineProperty(this, APP_SYMBOL, { value: true });
        this.loadContext(props.context, props.postCliContext);
        if (props.stackTraces === false) {
            this.node.setContext(cxapi.DISABLE_METADATA_STACK_TRACE, true);
        }
        if (props.defaultStackSynthesizer) {
            this.node.setContext(private_context_1.PRIVATE_CONTEXT_DEFAULT_STACK_SYNTHESIZER, props.defaultStackSynthesizer);
        }
        const analyticsReporting = props.analyticsReporting ?? props.runtimeInfo;
        if (analyticsReporting !== undefined) {
            this.node.setContext(cxapi.ANALYTICS_REPORTING_ENABLED_CONTEXT, analyticsReporting);
        }
        const autoSynth = props.autoSynth ?? cxapi.OUTDIR_ENV in process.env;
        if (autoSynth) {
            // synth() guarantuees it will only execute once, so a default of 'true'
            // doesn't bite manual calling of the function.
            process.once('beforeExit', () => this.synth());
        }
        this._treeMetadata = props.treeMetadata ?? true;
    }
    loadContext(defaults = {}, final = {}) {
        // prime with defaults passed through constructor
        for (const [k, v] of Object.entries(defaults)) {
            this.node.setContext(k, v);
        }
        // reconstructing the context from the two possible sources:
        const context = {
            ...this.readContextFromEnvironment(),
            ...this.readContextFromTempFile(),
        };
        for (const [k, v] of Object.entries(context)) {
            this.node.setContext(k, v);
        }
        // finalContext passed through constructor overwrites
        for (const [k, v] of Object.entries(final)) {
            this.node.setContext(k, v);
        }
    }
    readContextFromTempFile() {
        const location = process.env[cxapi.CONTEXT_OVERFLOW_LOCATION_ENV];
        return location ? fs.readJSONSync(location) : {};
    }
    readContextFromEnvironment() {
        const contextJson = process.env[cxapi.CONTEXT_ENV];
        return contextJson ? JSON.parse(contextJson) : {};
    }
}
_a = JSII_RTTI_SYMBOL_1;
App[_a] = { fqn: "@aws-cdk/core.App", version: "0.0.0" };
exports.App = App;
/**
 * Add a custom synthesis for the given construct
 *
 * When the construct is being synthesized, this allows it to add additional items
 * into the Cloud Assembly output.
 *
 * This feature is intended for use by official AWS CDK libraries only; 3rd party
 * library authors and CDK users should not use this function. That's why it's not
 * exposed via jsii.
 */
function attachCustomSynthesis(construct, synthesis) {
    // synthesis.ts where the implementation lives is not exported. So
    // this function is just a re-export of that function.
    (0, synthesis_1.addCustomSynthesis)(construct, synthesis);
}
exports.attachCustomSynthesis = attachCustomSynthesis;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlDQUF5QztBQUV6QywrQkFBK0I7QUFDL0IsK0RBQXNGO0FBQ3RGLG1EQUEyRTtBQUUzRSxtQ0FBZ0M7QUFFaEMsTUFBTSxVQUFVLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0FBa0huRDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQWEsR0FBSSxTQUFRLGFBQUs7SUFDNUI7Ozs7T0FJRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBUTtRQUMxQixPQUFPLFVBQVUsSUFBSSxHQUFHLENBQUM7S0FDMUI7SUFTRDs7O09BR0c7SUFDSCxZQUFZLFFBQWtCLEVBQUU7UUFDOUIsS0FBSyxDQUFDLFNBQWdCLEVBQUUsRUFBRSxFQUFFO1lBQzFCLE1BQU0sRUFBRSxLQUFLLENBQUMsTUFBTSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztTQUN0RCxDQUFDLENBQUM7Ozs7OzsrQ0F4Qk0sR0FBRzs7OztRQTBCWixNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVLEVBQUUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUV6RCxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLGNBQWMsQ0FBQyxDQUFDO1FBRXRELElBQUksS0FBSyxDQUFDLFdBQVcsS0FBSyxLQUFLLEVBQUU7WUFDL0IsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2hFO1FBRUQsSUFBSSxLQUFLLENBQUMsdUJBQXVCLEVBQUU7WUFDakMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsMkRBQXlDLEVBQUUsS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUM7U0FDaEc7UUFFRCxNQUFNLGtCQUFrQixHQUFHLEtBQUssQ0FBQyxrQkFBa0IsSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDO1FBRXpFLElBQUksa0JBQWtCLEtBQUssU0FBUyxFQUFFO1lBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyxtQ0FBbUMsRUFBRSxrQkFBa0IsQ0FBQyxDQUFDO1NBQ3JGO1FBRUQsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUM7UUFDckUsSUFBSSxTQUFTLEVBQUU7WUFDYix3RUFBd0U7WUFDeEUsK0NBQStDO1lBQy9DLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxFQUFFLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDO1NBQ2hEO1FBRUQsSUFBSSxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUMsWUFBWSxJQUFJLElBQUksQ0FBQztLQUNqRDtJQUVPLFdBQVcsQ0FBQyxXQUFzQyxFQUFHLEVBQUUsUUFBbUMsRUFBRTtRQUNsRyxpREFBaUQ7UUFDakQsS0FBSyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDN0MsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQzVCO1FBRUQsNERBQTREO1FBQzVELE1BQU0sT0FBTyxHQUFHO1lBQ2QsR0FBRyxJQUFJLENBQUMsMEJBQTBCLEVBQUU7WUFDcEMsR0FBRyxJQUFJLENBQUMsdUJBQXVCLEVBQUU7U0FDbEMsQ0FBQztRQUVGLEtBQUssTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQzVDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUM1QjtRQUVELHFEQUFxRDtRQUNyRCxLQUFLLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUMxQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7U0FDNUI7S0FDRjtJQUVPLHVCQUF1QjtRQUM3QixNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO1FBQ2xFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7S0FDbEQ7SUFFTywwQkFBMEI7UUFDaEMsTUFBTSxXQUFXLEdBQUcsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDbkQsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztLQUNuRDs7OztBQXBGVSxrQkFBRztBQXVGaEI7Ozs7Ozs7OztHQVNHO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsU0FBb0IsRUFBRSxTQUEyQjtJQUNyRixrRUFBa0U7SUFDbEUsc0RBQXNEO0lBQ3RELElBQUEsOEJBQWtCLEVBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0FBQzNDLENBQUM7QUFKRCxzREFJQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IFBSSVZBVEVfQ09OVEVYVF9ERUZBVUxUX1NUQUNLX1NZTlRIRVNJWkVSIH0gZnJvbSAnLi9wcml2YXRlL3ByaXZhdGUtY29udGV4dCc7XG5pbXBvcnQgeyBhZGRDdXN0b21TeW50aGVzaXMsIElDdXN0b21TeW50aGVzaXMgfSBmcm9tICcuL3ByaXZhdGUvc3ludGhlc2lzJztcbmltcG9ydCB7IElSZXVzYWJsZVN0YWNrU3ludGhlc2l6ZXIgfSBmcm9tICcuL3N0YWNrLXN5bnRoZXNpemVycyc7XG5pbXBvcnQgeyBTdGFnZSB9IGZyb20gJy4vc3RhZ2UnO1xuXG5jb25zdCBBUFBfU1lNQk9MID0gU3ltYm9sLmZvcignQGF3cy1jZGsvY29yZS5BcHAnKTtcblxuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBwcm9wcyBmb3IgYXBwcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBcHBQcm9wcyB7XG4gIC8qKlxuICAgKiBBdXRvbWF0aWNhbGx5IGNhbGwgYHN5bnRoKClgIGJlZm9yZSB0aGUgcHJvZ3JhbSBleGl0cy5cbiAgICpcbiAgICogSWYgeW91IHNldCB0aGlzLCB5b3UgZG9uJ3QgaGF2ZSB0byBjYWxsIGBzeW50aCgpYCBleHBsaWNpdGx5LiBOb3RlIHRoYXRcbiAgICogdGhpcyBmZWF0dXJlIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBjZXJ0YWluIHByb2dyYW1taW5nIGxhbmd1YWdlcywgYW5kXG4gICAqIGNhbGxpbmcgYHN5bnRoKClgIGlzIHN0aWxsIHJlY29tbWVuZGVkLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlIGlmIHJ1bm5pbmcgdmlhIENESyBDTEkgKGBDREtfT1VURElSYCBpcyBzZXQpLCBgZmFsc2VgXG4gICAqIG90aGVyd2lzZVxuICAgKi9cbiAgcmVhZG9ubHkgYXV0b1N5bnRoPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIG91dHB1dCBkaXJlY3RvcnkgaW50byB3aGljaCB0byBlbWl0IHN5bnRoZXNpemVkIGFydGlmYWN0cy5cbiAgICpcbiAgICogWW91IHNob3VsZCBuZXZlciBuZWVkIHRvIHNldCB0aGlzIHZhbHVlLiBCeSBkZWZhdWx0LCB0aGUgdmFsdWUgeW91IHBhc3MgdG9cbiAgICogdGhlIENMSSdzIGAtLW91dHB1dGAgZmxhZyB3aWxsIGJlIHVzZWQsIGFuZCBpZiB5b3UgY2hhbmdlIGl0IHRvIGEgZGlmZmVyZW50XG4gICAqIGRpcmVjdG9yeSB0aGUgQ0xJIHdpbGwgZmFpbCB0byBwaWNrIHVwIHRoZSBnZW5lcmF0ZWQgQ2xvdWQgQXNzZW1ibHkuXG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgaXMgaW50ZW5kZWQgZm9yIGludGVybmFsIGFuZCB0ZXN0aW5nIHVzZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBJZiB0aGlzIHZhbHVlIGlzIF9ub3RfIHNldCwgY29uc2lkZXJzIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBgQ0RLX09VVERJUmAuXG4gICAqICAgICAgICAgICAgSWYgYENES19PVVRESVJgIGlzIG5vdCBkZWZpbmVkLCB1c2VzIGEgdGVtcCBkaXJlY3RvcnkuXG4gICAqL1xuICByZWFkb25seSBvdXRkaXI/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgY29uc3RydWN0IGNyZWF0aW9uIHN0YWNrIHRyYWNlIGluIHRoZSBgYXdzOmNkazp0cmFjZWAgbWV0YWRhdGEga2V5IG9mIGFsbCBjb25zdHJ1Y3RzLlxuICAgKiBAZGVmYXVsdCB0cnVlIHN0YWNrIHRyYWNlcyBhcmUgaW5jbHVkZWQgdW5sZXNzIGBhd3M6Y2RrOmRpc2FibGUtc3RhY2stdHJhY2VgIGlzIHNldCBpbiB0aGUgY29udGV4dC5cbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrVHJhY2VzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5jbHVkZSBydW50aW1lIHZlcnNpb25pbmcgaW5mb3JtYXRpb24gaW4gdGhlIFN0YWNrcyBvZiB0aGlzIGFwcFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHZlcnNpb25SZXBvcnRpbmdgIGluc3RlYWRcbiAgICogQGRlZmF1bHQgVmFsdWUgb2YgJ2F3czpjZGs6dmVyc2lvbi1yZXBvcnRpbmcnIGNvbnRleHQga2V5XG4gICAqL1xuICByZWFkb25seSBydW50aW1lSW5mbz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgcnVudGltZSB2ZXJzaW9uaW5nIGluZm9ybWF0aW9uIGluIHRoZSBTdGFja3Mgb2YgdGhpcyBhcHBcbiAgICpcbiAgICogQGRlZmF1bHQgVmFsdWUgb2YgJ2F3czpjZGs6dmVyc2lvbi1yZXBvcnRpbmcnIGNvbnRleHQga2V5XG4gICAqL1xuICByZWFkb25seSBhbmFseXRpY3NSZXBvcnRpbmc/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGNvbnRleHQgdmFsdWVzIGZvciB0aGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIENvbnRleHQgc2V0IGJ5IHRoZSBDTEkgb3IgdGhlIGBjb250ZXh0YCBrZXkgaW4gYGNkay5qc29uYCBoYXMgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQ29udGV4dCBjYW4gYmUgcmVhZCBmcm9tIGFueSBjb25zdHJ1Y3QgdXNpbmcgYG5vZGUuZ2V0Q29udGV4dChrZXkpYC5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBhZGRpdGlvbmFsIGNvbnRleHRcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRleHQ/OiB7IFtrZXk6IHN0cmluZ106IGFueSB9O1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGNvbnRleHQgdmFsdWVzIGZvciB0aGUgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIENvbnRleHQgcHJvdmlkZWQgaGVyZSBoYXMgcHJlY2VkZW5jZSBvdmVyIGNvbnRleHQgc2V0IGJ5OlxuICAgKlxuICAgKiAtIFRoZSBDTEkgdmlhIC0tY29udGV4dFxuICAgKiAtIFRoZSBgY29udGV4dGAga2V5IGluIGBjZGsuanNvbmBcbiAgICogLSBUaGUgYEFwcFByb3BzLmNvbnRleHRgIHByb3BlcnR5XG4gICAqXG4gICAqIFRoaXMgcHJvcGVydHkgaXMgcmVjb21tZW5kZWQgb3ZlciB0aGUgYEFwcFByb3BzLmNvbnRleHRgIHByb3BlcnR5IHNpbmNlIHlvdVxuICAgKiBjYW4gbWFrZSBmaW5hbCBkZWNpc2lvbiBvdmVyIHdoaWNoIGNvbnRleHQgdmFsdWUgdG8gdGFrZSBpbiB5b3VyIGFwcC5cbiAgICpcbiAgICogQ29udGV4dCBjYW4gYmUgcmVhZCBmcm9tIGFueSBjb25zdHJ1Y3QgdXNpbmcgYG5vZGUuZ2V0Q29udGV4dChrZXkpYC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogLy8gY29udGV4dCBmcm9tIHRoZSBDTEkgYW5kIGZyb20gYGNkay5qc29uYCBhcmUgc3RvcmVkIGluIHRoZVxuICAgKiAvLyBDREtfQ09OVEVYVCBlbnYgdmFyaWFibGVcbiAgICogY29uc3QgY2xpQ29udGV4dCA9IEpTT04ucGFyc2UocHJvY2Vzcy5lbnYuQ0RLX0NPTlRFWFQhKTtcbiAgICpcbiAgICogLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdGFrZSB0aGUgY29udGV4dCBwYXNzZWQgaW4gdGhlIENMSSBvciBub3RcbiAgICogY29uc3QgZGV0ZXJtaW5lVmFsdWUgPSBwcm9jZXNzLmVudi5QUk9EID8gY2xpQ29udGV4dC5TT01FS0VZIDogJ215LXByb2QtdmFsdWUnO1xuICAgKiBuZXcgQXBwKHtcbiAgICogICBwb3N0Q2xpQ29udGV4dDoge1xuICAgKiAgICAgU09NRUtFWTogZGV0ZXJtaW5lVmFsdWUsXG4gICAqICAgfSxcbiAgICogfSk7XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm8gYWRkaXRpb25hbCBjb250ZXh0XG4gICAqL1xuICByZWFkb25seSBwb3N0Q2xpQ29udGV4dD86IHsgW2tleTogc3RyaW5nXTogYW55IH07XG5cbiAgLyoqXG4gICAqIEluY2x1ZGUgY29uc3RydWN0IHRyZWUgbWV0YWRhdGEgYXMgcGFydCBvZiB0aGUgQ2xvdWQgQXNzZW1ibHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHRyZWVNZXRhZGF0YT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjayBzeW50aGVzaXplciB0byB1c2UgYnkgZGVmYXVsdCBmb3IgYWxsIFN0YWNrcyBpbiB0aGUgQXBwXG4gICAqXG4gICAqIFRoZSBTdGFjayBTeW50aGVzaXplciBjb250cm9scyBhc3BlY3RzIG9mIHN5bnRoZXNpcyBhbmQgZGVwbG95bWVudCxcbiAgICogbGlrZSBob3cgYXNzZXRzIGFyZSByZWZlcmVuY2VkIGFuZCB3aGF0IElBTSByb2xlcyB0byB1c2UuIEZvciBtb3JlXG4gICAqIGluZm9ybWF0aW9uLCBzZWUgdGhlIFJFQURNRSBvZiB0aGUgbWFpbiBDREsgcGFja2FnZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBBIGBEZWZhdWx0U3RhY2tTeW50aGVzaXplcmAgd2l0aCBkZWZhdWx0IHNldHRpbmdzXG4gICAqL1xuICByZWFkb25seSBkZWZhdWx0U3RhY2tTeW50aGVzaXplcj86IElSZXVzYWJsZVN0YWNrU3ludGhlc2l6ZXI7XG59XG5cbi8qKlxuICogQSBjb25zdHJ1Y3Qgd2hpY2ggcmVwcmVzZW50cyBhbiBlbnRpcmUgQ0RLIGFwcC4gVGhpcyBjb25zdHJ1Y3QgaXMgbm9ybWFsbHlcbiAqIHRoZSByb290IG9mIHRoZSBjb25zdHJ1Y3QgdHJlZS5cbiAqXG4gKiBZb3Ugd291bGQgbm9ybWFsbHkgZGVmaW5lIGFuIGBBcHBgIGluc3RhbmNlIGluIHlvdXIgcHJvZ3JhbSdzIGVudHJ5cG9pbnQsXG4gKiB0aGVuIGRlZmluZSBjb25zdHJ1Y3RzIHdoZXJlIHRoZSBhcHAgaXMgdXNlZCBhcyB0aGUgcGFyZW50IHNjb3BlLlxuICpcbiAqIEFmdGVyIGFsbCB0aGUgY2hpbGQgY29uc3RydWN0cyBhcmUgZGVmaW5lZCB3aXRoaW4gdGhlIGFwcCwgeW91IHNob3VsZCBjYWxsXG4gKiBgYXBwLnN5bnRoKClgIHdoaWNoIHdpbGwgZW1pdCBhIFwiY2xvdWQgYXNzZW1ibHlcIiBmcm9tIHRoaXMgYXBwIGludG8gdGhlXG4gKiBkaXJlY3Rvcnkgc3BlY2lmaWVkIGJ5IGBvdXRkaXJgLiBDbG91ZCBhc3NlbWJsaWVzIGluY2x1ZGVzIGFydGlmYWN0cyBzdWNoIGFzXG4gKiBDbG91ZEZvcm1hdGlvbiB0ZW1wbGF0ZXMgYW5kIGFzc2V0cyB0aGF0IGFyZSBuZWVkZWQgdG8gZGVwbG95IHRoaXMgYXBwIGludG9cbiAqIHRoZSBBV1MgY2xvdWQuXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vY2RrL2xhdGVzdC9ndWlkZS9hcHBzLmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIFN0YWdlIHtcbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIGBBcHBgIGNsYXNzLlxuICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgYG9iamAgaXMgYW4gYEFwcGAuXG4gICAqIEBwYXJhbSBvYmogVGhlIG9iamVjdCB0byBldmFsdWF0ZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBpc0FwcChvYmo6IGFueSk6IG9iaiBpcyBBcHAge1xuICAgIHJldHVybiBBUFBfU1lNQk9MIGluIG9iajtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNsdWRlIGNvbnN0cnVjdCB0cmVlIG1ldGFkYXRhIGFzIHBhcnQgb2YgdGhlIENsb3VkIEFzc2VtYmx5LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBfdHJlZU1ldGFkYXRhOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIENESyBhcHBsaWNhdGlvbi5cbiAgICogQHBhcmFtIHByb3BzIGluaXRpYWxpemF0aW9uIHByb3BlcnRpZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHByb3BzOiBBcHBQcm9wcyA9IHt9KSB7XG4gICAgc3VwZXIodW5kZWZpbmVkIGFzIGFueSwgJycsIHtcbiAgICAgIG91dGRpcjogcHJvcHMub3V0ZGlyID8/IHByb2Nlc3MuZW52W2N4YXBpLk9VVERJUl9FTlZdLFxuICAgIH0pO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIEFQUF9TWU1CT0wsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgICB0aGlzLmxvYWRDb250ZXh0KHByb3BzLmNvbnRleHQsIHByb3BzLnBvc3RDbGlDb250ZXh0KTtcblxuICAgIGlmIChwcm9wcy5zdGFja1RyYWNlcyA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRDb250ZXh0KGN4YXBpLkRJU0FCTEVfTUVUQURBVEFfU1RBQ0tfVFJBQ0UsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChwcm9wcy5kZWZhdWx0U3RhY2tTeW50aGVzaXplcikge1xuICAgICAgdGhpcy5ub2RlLnNldENvbnRleHQoUFJJVkFURV9DT05URVhUX0RFRkFVTFRfU1RBQ0tfU1lOVEhFU0laRVIsIHByb3BzLmRlZmF1bHRTdGFja1N5bnRoZXNpemVyKTtcbiAgICB9XG5cbiAgICBjb25zdCBhbmFseXRpY3NSZXBvcnRpbmcgPSBwcm9wcy5hbmFseXRpY3NSZXBvcnRpbmcgPz8gcHJvcHMucnVudGltZUluZm87XG5cbiAgICBpZiAoYW5hbHl0aWNzUmVwb3J0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRDb250ZXh0KGN4YXBpLkFOQUxZVElDU19SRVBPUlRJTkdfRU5BQkxFRF9DT05URVhULCBhbmFseXRpY3NSZXBvcnRpbmcpO1xuICAgIH1cblxuICAgIGNvbnN0IGF1dG9TeW50aCA9IHByb3BzLmF1dG9TeW50aCA/PyBjeGFwaS5PVVRESVJfRU5WIGluIHByb2Nlc3MuZW52O1xuICAgIGlmIChhdXRvU3ludGgpIHtcbiAgICAgIC8vIHN5bnRoKCkgZ3VhcmFudHVlZXMgaXQgd2lsbCBvbmx5IGV4ZWN1dGUgb25jZSwgc28gYSBkZWZhdWx0IG9mICd0cnVlJ1xuICAgICAgLy8gZG9lc24ndCBiaXRlIG1hbnVhbCBjYWxsaW5nIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgIHByb2Nlc3Mub25jZSgnYmVmb3JlRXhpdCcsICgpID0+IHRoaXMuc3ludGgoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHJlZU1ldGFkYXRhID0gcHJvcHMudHJlZU1ldGFkYXRhID8/IHRydWU7XG4gIH1cblxuICBwcml2YXRlIGxvYWRDb250ZXh0KGRlZmF1bHRzOiB7IFtrZXk6IHN0cmluZ106IHN0cmluZyB9ID0geyB9LCBmaW5hbDogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgLy8gcHJpbWUgd2l0aCBkZWZhdWx0cyBwYXNzZWQgdGhyb3VnaCBjb25zdHJ1Y3RvclxuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKGRlZmF1bHRzKSkge1xuICAgICAgdGhpcy5ub2RlLnNldENvbnRleHQoaywgdik7XG4gICAgfVxuXG4gICAgLy8gcmVjb25zdHJ1Y3RpbmcgdGhlIGNvbnRleHQgZnJvbSB0aGUgdHdvIHBvc3NpYmxlIHNvdXJjZXM6XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIC4uLnRoaXMucmVhZENvbnRleHRGcm9tRW52aXJvbm1lbnQoKSxcbiAgICAgIC4uLnRoaXMucmVhZENvbnRleHRGcm9tVGVtcEZpbGUoKSxcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoY29udGV4dCkpIHtcbiAgICAgIHRoaXMubm9kZS5zZXRDb250ZXh0KGssIHYpO1xuICAgIH1cblxuICAgIC8vIGZpbmFsQ29udGV4dCBwYXNzZWQgdGhyb3VnaCBjb25zdHJ1Y3RvciBvdmVyd3JpdGVzXG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoZmluYWwpKSB7XG4gICAgICB0aGlzLm5vZGUuc2V0Q29udGV4dChrLCB2KTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHJlYWRDb250ZXh0RnJvbVRlbXBGaWxlKCkge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvY2Vzcy5lbnZbY3hhcGkuQ09OVEVYVF9PVkVSRkxPV19MT0NBVElPTl9FTlZdO1xuICAgIHJldHVybiBsb2NhdGlvbiA/IGZzLnJlYWRKU09OU3luYyhsb2NhdGlvbikgOiB7fTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZENvbnRleHRGcm9tRW52aXJvbm1lbnQoKSB7XG4gICAgY29uc3QgY29udGV4dEpzb24gPSBwcm9jZXNzLmVudltjeGFwaS5DT05URVhUX0VOVl07XG4gICAgcmV0dXJuIGNvbnRleHRKc29uID8gSlNPTi5wYXJzZShjb250ZXh0SnNvbikgOiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZCBhIGN1c3RvbSBzeW50aGVzaXMgZm9yIHRoZSBnaXZlbiBjb25zdHJ1Y3RcbiAqXG4gKiBXaGVuIHRoZSBjb25zdHJ1Y3QgaXMgYmVpbmcgc3ludGhlc2l6ZWQsIHRoaXMgYWxsb3dzIGl0IHRvIGFkZCBhZGRpdGlvbmFsIGl0ZW1zXG4gKiBpbnRvIHRoZSBDbG91ZCBBc3NlbWJseSBvdXRwdXQuXG4gKlxuICogVGhpcyBmZWF0dXJlIGlzIGludGVuZGVkIGZvciB1c2UgYnkgb2ZmaWNpYWwgQVdTIENESyBsaWJyYXJpZXMgb25seTsgM3JkIHBhcnR5XG4gKiBsaWJyYXJ5IGF1dGhvcnMgYW5kIENESyB1c2VycyBzaG91bGQgbm90IHVzZSB0aGlzIGZ1bmN0aW9uLiBUaGF0J3Mgd2h5IGl0J3Mgbm90XG4gKiBleHBvc2VkIHZpYSBqc2lpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNoQ3VzdG9tU3ludGhlc2lzKGNvbnN0cnVjdDogQ29uc3RydWN0LCBzeW50aGVzaXM6IElDdXN0b21TeW50aGVzaXMpOiB2b2lkIHtcbiAgLy8gc3ludGhlc2lzLnRzIHdoZXJlIHRoZSBpbXBsZW1lbnRhdGlvbiBsaXZlcyBpcyBub3QgZXhwb3J0ZWQuIFNvXG4gIC8vIHRoaXMgZnVuY3Rpb24gaXMganVzdCBhIHJlLWV4cG9ydCBvZiB0aGF0IGZ1bmN0aW9uLlxuICBhZGRDdXN0b21TeW50aGVzaXMoY29uc3RydWN0LCBzeW50aGVzaXMpO1xufVxuIl19