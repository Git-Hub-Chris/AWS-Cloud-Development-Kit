import * as iam from '@aws-cdk/aws-iam';
import * as sns from '@aws-cdk/aws-sns';
import { IResource, Resource, Names, Lazy, Stack } from '@aws-cdk/core';
import { Construct } from 'constructs';
import { IAnomalyMonitor } from './anomaly-monitor';
import { CfnAnomalySubscription } from './ce.generated';

/**
 * The frequency that anomaly reports are sent over email.
 */
export enum Frequency {
  /**
   * Daily.
   */
  DAILY = 'DAILY',

  /**
   * Immediately.
   */
  IMMEDIATE = 'IMMEDIATE',

  /**
   * Weekly.
   */
  WEEKLY = 'WEEKLY'
}

/**
 * An abstract target for anomaly subscriptions.
 */
export interface ISubscriber {
  /**
   * Returns the subscriber specification.
   *
   * @param anomalySubscription The anomaly subscription to subscribe to.
   */
  bind(anomalySubscription: IAnomalySubscription): SubscriberConfig
}

/**
 * Properties for a subscriber.
 */
export interface SubscriberConfig {
  /**
   * The email address or SNS Topic ARN, depending on the Type.
   */
  readonly address: string;

  /**
   * The notification delivery channel.
   */
  readonly type: 'EMAIL' | 'SNS';
}

/**
 * Use an SNS topic as a subscriber for an anomaly subscription.
 */
export class SnsTopic implements ISubscriber {
  constructor(public readonly topic: sns.ITopic) {
  }

  /**
   * Returns a SubscriberConfig that can be used to subscribe this SNS topic to an anomaly monitor subscription.
   *
   * @see https://docs.aws.amazon.com/awsaccountbilling/latest/aboutv2/ad-SNS.html
   */
  public bind(_anomalySubscription: IAnomalySubscription): SubscriberConfig {
    this.topic.grantPublish(new iam.ServicePrincipal('costalerts.amazonaws.com'));

    return {
      address: this.topic.topicArn,
      type: 'SNS',
    };
  }
}

/**
 * Use an email address as a subscriber for an anomaly subscription.
 */
export class Email implements ISubscriber {
  constructor(public readonly address: string) { }

  /**
   * Returns a SubscriberConfig that can be used to subscribe this email address to an anomaly monitor subscription.
   */
  public bind(_anomalySubscription: IAnomalySubscription): SubscriberConfig {
    return {
      address: this.address,
      type: 'EMAIL',
    };
  }
}

/**
 * Properties of an anomaly subscription.
 */
export interface AnomalySubscriptionProps {
  /**
   * The frequency that anomaly reports are sent over email.
   *
   * @default Frequency.IMMEDIATE
   */
  readonly frequency?: Frequency;

  /**
   * A list of cost anomaly monitors.
   */
  readonly monitors: IAnomalyMonitor[];

  /**
   * A list of subscribers to notify.
   */
  readonly subscribers: ISubscriber[];

  /**
   * A name for the subscription.
   *
   * @default - autogenerated name
   */
  readonly anomalySubscriptionName?: string;

  /**
   * The dollar value that triggers a notification if the threshold is exceeded.
   */
  readonly threshold: number;
}

/**
 * Properties of an anomaly subscription.
 */
export interface IAnomalySubscription extends IResource {
  /**
  * The ARN of this anomaly subscription
  *
  * @attribute
  */
  readonly anomalySubscriptionSubscriptionArn: string;

  /**
  * The account the subscription is created in.
  *
  * @attribute
  */
  readonly anomalySubscriptionAccountId: string;
}

/**
* Anomaly subscription.
*
* Associates a monitor, threshold, and list of subscribers. It delivers notifications about anomalies detected by a
* monitor that exceeds a threshold. The content consists of the detailed metadata and the current status of the
* AnomalySubscription object.
*/
export class AnomalySubscription extends Resource implements IAnomalySubscription {

  /**
   * Fetches an existing anomaly subscription by its Amazon resource name.
   *
   * @param scope
   * @param id
   * @param anomalySubscriptionArn
   */
  public static fromAnomalySubscriptionArn(scope: Construct, id: string, anomalySubscriptionArn: string): IAnomalySubscription {
    const stack = Stack.of(scope);
    const anomalySubscriptionAccountId = stack.parseArn(anomalySubscriptionArn).account!;

    class Import extends Resource implements IAnomalySubscription {
      public readonly anomalySubscriptionSubscriptionArn = anomalySubscriptionArn;
      public readonly anomalySubscriptionAccountId = anomalySubscriptionAccountId;
    }

    return new Import(scope, id);
  }

  /**
  * The ARN of this anomaly subscription
  *
  * @attribute
  */
  readonly anomalySubscriptionSubscriptionArn: string;

  /**
  * The account the subscription is created in.
  *
  * @attribute
  */
  readonly anomalySubscriptionAccountId: string;

  private readonly subscribers = new Array<CfnAnomalySubscription.SubscriberProperty>();

  constructor(scope: Construct, id: string, props: AnomalySubscriptionProps) {
    super(scope, id, {
      physicalName: props.anomalySubscriptionName ||
        Lazy.string({ produce: () => Names.nodeUniqueId(this.node) }),
    });

    const frequency = props.frequency || Frequency.IMMEDIATE;
    if (props.subscribers.length < 1) {
      throw new Error(`Need to provide at least 1 subscriber, got: ${props.subscribers.length}`);
    }
    if ((props.subscribers.some(s => s instanceof SnsTopic)) && frequency != Frequency.IMMEDIATE) {
      throw new Error(`Sns-based anomaly subscriptions are only supported for DAILY and WEEKLY frequencies, got: ${props.frequency}`);
    }
    if (frequency == Frequency.IMMEDIATE && props.subscribers.length > 1) {
      throw new Error(`Immediate frequencies only support a max of one subscriber, got: ${props.subscribers.length}`);
    }
    if (frequency == Frequency.IMMEDIATE && props.subscribers.some(s => !(s instanceof SnsTopic))) {
      throw new Error('Immediate frequencies only support SNSTopic subscriptions.');
    }

    const subscription = new CfnAnomalySubscription(this, 'Resource', {
      frequency: frequency,
      subscribers: Lazy.any({ produce: () => this.renderSubscribers() }),
      monitorArnList: props.monitors.map(m => m.anomalyMonitorMonitorArn),
      subscriptionName: this.physicalName,
      threshold: props.threshold,
    });

    this.anomalySubscriptionSubscriptionArn = this.getResourceArnAttribute(subscription.ref, {
      service: 'ce',
      resource: 'anomalysubscription',
      resourceName: this.physicalName,
    });

    const stack = Stack.of(scope);
    this.anomalySubscriptionAccountId = stack.parseArn(this.anomalySubscriptionSubscriptionArn).account!;

    for (const subscriber of props.subscribers || []) {
      this.subscribers.push(subscriber.bind(this));
    }

  }

  private renderSubscribers() {
    return this.subscribers;
  }
}
