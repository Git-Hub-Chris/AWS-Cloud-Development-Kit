import { Template, Match } from '@aws-cdk/assertions';
import * as iam from '@aws-cdk/aws-iam';
import * as kms from '@aws-cdk/aws-kms';
import * as s3 from '@aws-cdk/aws-s3';
import * as cdk from '@aws-cdk/core';
import * as glue from '../lib';
import { PartitionIndex } from '../lib';
import { CfnTable } from '../lib/glue.generated';

test('specifying serDe parameters json', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.json({
      caseInsensitive: false,
      mappings: {
        col: 'Col',
      },
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
          Parameters: {
            'case.insensitive': 'false',
            'mapping.col': 'Col',
          },
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('specifying serDe parameters csv', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.csv({
      escapeChar: '$',
      separatorChar: '|',
      quoteChar: '\'',
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'csv',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.apache.hadoop.hive.serde2.OpenCSVSerde',
          Parameters: {
            separatorChar: '|',
            quoteChar: '\'',
            escapeChar: '$',
          },
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});

test('specifying serDe parameters avro', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'flights_avro_example',
    columns: [{
      name: 'yr',
      type: glue.Schema.INTEGER,
    }, {
      name: 'flightdate',
      type: glue.Schema.STRING,
    }, {
      name: 'uniquecarrier',
      type: glue.Schema.STRING,
    }, {
      name: 'airlineid',
      type: glue.Schema.INTEGER,
    }, {
      name: 'carrier',
      type: glue.Schema.STRING,
    }, {
      name: 'flightnum',
      type: glue.Schema.STRING,
    }, {
      name: 'origin',
      type: glue.Schema.STRING,
    }, {
      name: 'dest',
      type: glue.Schema.STRING,
    }, {
      name: 'depdelay',
      type: glue.Schema.INTEGER,
    }, {
      name: 'carrierdelay',
      type: glue.Schema.INTEGER,
    }, {
      name: 'weatherdelay',
      type: glue.Schema.INTEGER,
    }],
    dataFormat: glue.DataFormat.avro({
      schema: {
        type: 'record',
        name: 'flights_avro_subset',
        namespace: 'default',
        fields: [{
          name: 'yr',
          type: ['null', 'int'],
          default: null,
        }, {
          name: 'flightdate',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'uniquecarrier',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'airlineid',
          type: ['null', 'int'],
          default: null,
        }, {
          name: 'carrier',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'flightnum',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'origin',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'dest',
          type: ['null', 'string'],
          default: null,
        }, {
          name: 'depdelay',
          type: ['null', 'int'],
          default: null,
        }, {
          name: 'carrierdelay',
          type: ['null', 'int'],
          default: null,
        }, {
          name: 'weatherdelay',
          type: ['null', 'int'],
          default: null,
        }],
      },
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'flights_avro_example',
      Description: 'flights_avro_example generated by CDK',
      Parameters: {
        classification: 'avro',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'yr',
            Type: 'int',
          }, {
            Name: 'flightdate',
            Type: 'string',
          }, {
            Name: 'uniquecarrier',
            Type: 'string',
          }, {
            Name: 'airlineid',
            Type: 'int',
          }, {
            Name: 'carrier',
            Type: 'string',
          }, {
            Name: 'flightnum',
            Type: 'string',
          }, {
            Name: 'origin',
            Type: 'string',
          }, {
            Name: 'dest',
            Type: 'string',
          }, {
            Name: 'depdelay',
            Type: 'int',
          }, {
            Name: 'carrierdelay',
            Type: 'int',
          }, {
            Name: 'weatherdelay',
            Type: 'int',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.hive.ql.io.avro.AvroContainerInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.avro.AvroContainerOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.apache.hadoop.hive.serde2.avro.AvroSerDe',
          Parameters: {
            'avro.schema.literal': '{"type":"record","name":"flights_avro_subset","namespace":"default","fields":[{"name":"yr","type":["null","int"],"default":null},{"name":"flightdate","type":["null","string"],"default":null},{"name":"uniquecarrier","type":["null","string"],"default":null},{"name":"airlineid","type":["null","int"],"default":null},{"name":"carrier","type":["null","string"],"default":null},{"name":"flightnum","type":["null","string"],"default":null},{"name":"origin","type":["null","string"],"default":null},{"name":"dest","type":["null","string"],"default":null},{"name":"depdelay","type":["null","int"],"default":null},{"name":"carrierdelay","type":["null","int"],"default":null},{"name":"weatherdelay","type":["null","int"],"default":null}]}',
          },
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});

test('specifying serDe parameters logstash', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 's3_access_auto_raw_02',
    columns: [{
      name: 'bucket_owner',
      type: glue.Schema.STRING,
    }, {
      name: 'bucket',
      type: glue.Schema.STRING,
    }, {
      name: 'flightdate',
      type: glue.Schema.STRING,
    }, {
      name: 'time',
      type: glue.Schema.STRING,
    }, {
      name: 'remote_ip',
      type: glue.Schema.STRING,
    }, {
      name: 'requester',
      type: glue.Schema.STRING,
    }, {
      name: 'request_id',
      type: glue.Schema.STRING,
    }, {
      name: 'operation',
      type: glue.Schema.STRING,
    }, {
      name: 'key',
      type: glue.Schema.STRING,
    }, {
      name: 'request_uri',
      type: glue.Schema.STRING,
    }, {
      name: 'http_status',
      type: glue.Schema.STRING,
    }, {
      name: 'error_code',
      type: glue.Schema.STRING,
    }, {
      name: 'bytes_sent',
      type: glue.Schema.STRING,
    }, {
      name: 'object_size',
      type: glue.Schema.STRING,
    }, {
      name: 'total_time',
      type: glue.Schema.STRING,
    }, {
      name: 'referrer',
      type: glue.Schema.STRING,
    }, {
      name: 'user_agent',
      type: glue.Schema.STRING,
    }, {
      name: 'version_id',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.logstash({
      format: '%{NOTSPACE:bucket_owner} %{NOTSPACE:bucket} \\[%{INSIDE_BRACKETS:time}\\] %{NOTSPACE:remote_ip} %{NOTSPACE:requester} %{NOTSPACE:request_id} %{NOTSPACE:operation} %{NOTSPACE:key} \"?%{INSIDE_QS:request_uri}\"? %{NOTSPACE:http_status} %{NOTSPACE:error_code} %{NOTSPACE:bytes_sent} %{NOTSPACE:object_size} %{NOTSPACE:total_time} %{NOTSPACE:turnaround_time} \"?%{INSIDE_QS:referrer}\"? \"?%{INSIDE_QS:user_agent}\"? %{NOTSPACE:version_id}',
      customPattern: {
        INSIDE_QS: '([^\"]*)',
        INSIDE_BRACKETS: '([^\\]]*)',
      },
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 's3_access_auto_raw_02',
      Description: 's3_access_auto_raw_02 generated by CDK',
      Parameters: {
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'bucket_owner',
            Type: 'string',
          }, {
            Name: 'bucket',
            Type: 'string',
          }, {
            Name: 'flightdate',
            Type: 'string',
          }, {
            Name: 'time',
            Type: 'string',
          }, {
            Name: 'remote_ip',
            Type: 'string',
          }, {
            Name: 'requester',
            Type: 'string',
          }, {
            Name: 'request_id',
            Type: 'string',
          }, {
            Name: 'operation',
            Type: 'string',
          }, {
            Name: 'key',
            Type: 'string',
          }, {
            Name: 'request_uri',
            Type: 'string',
          }, {
            Name: 'http_status',
            Type: 'string',
          }, {
            Name: 'error_code',
            Type: 'string',
          }, {
            Name: 'bytes_sent',
            Type: 'string',
          }, {
            Name: 'object_size',
            Type: 'string',
          }, {
            Name: 'total_time',
            Type: 'string',
          }, {
            Name: 'referrer',
            Type: 'string',
          }, {
            Name: 'user_agent',
            Type: 'string',
          }, {
            Name: 'version_id',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'com.amazonaws.glue.serde.GrokSerDe',
          Parameters: {
            'input.format': '%{NOTSPACE:bucket_owner} %{NOTSPACE:bucket} \\[%{INSIDE_BRACKETS:time}\\] %{NOTSPACE:remote_ip} %{NOTSPACE:requester} %{NOTSPACE:request_id} %{NOTSPACE:operation} %{NOTSPACE:key} \"?%{INSIDE_QS:request_uri}\"? %{NOTSPACE:http_status} %{NOTSPACE:error_code} %{NOTSPACE:bytes_sent} %{NOTSPACE:object_size} %{NOTSPACE:total_time} %{NOTSPACE:turnaround_time} \"?%{INSIDE_QS:referrer}\"? \"?%{INSIDE_QS:user_agent}\"? %{NOTSPACE:version_id}',
            'input.grokCustomPatterns': 'INSIDE_QS ([^\"]*)\nINSIDE_BRACKETS ([^\\]]*)',
          },
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});


test('specifying serDe parameters orc', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'orcTable',
    columns: [{
      name: 'col1',
      type: glue.Schema.STRING,
    }, {
      name: 'col2',
      type: glue.Schema.INTEGER,
    }],
    dataFormat: glue.DataFormat.orc({
      compression: glue.OrcSerDeOptionCompress.ZLIB,
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'orcTable',
      Description: 'orcTable generated by CDK',
      Parameters: {
        classification: 'orc',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col1',
            Type: 'string',
          }, {
            Name: 'col2',
            Type: 'int',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.hive.ql.io.orc.OrcInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.apache.hadoop.hive.ql.io.orc.OrcSerde',
        },
        StoredAsSubDirectories: false,
        Parameters: {
          'orc.compress': 'ZLIB',
        },
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});

test('specifying serDe parameters parquet', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'parquetTable',
    columns: [{
      name: 'col1',
      type: glue.Schema.STRING,
    }, {
      name: 'col2',
      type: glue.Schema.INTEGER,
    }],
    dataFormat: glue.DataFormat.parquet({
      compression: glue.ParquetSerDeOptionCompress.SNAPPY,
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'parquetTable',
      Description: 'parquetTable generated by CDK',
      Parameters: {
        classification: 'parquet',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col1',
            Type: 'string',
          }, {
            Name: 'col2',
            Type: 'int',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.parquet.MapredParquetOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.apache.hadoop.hive.ql.io.parquet.serde.ParquetHiveSerDe',
        },
        StoredAsSubDirectories: false,
        Parameters: {
          'parquet.compression': 'snappy',
        },
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});

test('specifying serDe parameters tsv', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'tsvTable',
    columns: [{
      name: 'col1',
      type: glue.Schema.STRING,
    }, {
      name: 'col2',
      type: glue.Schema.INTEGER,
    }],
    dataFormat: glue.DataFormat.tsv({
      skipHeaderLineCount: 1,
      escapeDelimiter: '\\',
      lineDelimiter: '\n',
      fieldDelimiter: ',',
    }),
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'tsvTable',
      Description: 'tsvTable generated by CDK',
      Parameters: {
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col1',
            Type: 'string',
          }, {
            Name: 'col2',
            Type: 'int',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.apache.hadoop.hive.serde2.lazy.LazySimpleSerDe',
          Parameters: {
            'escape.delim': '\\',
            'field.delim': ',',
            'line.delim': '\n',
            'serialization.format': ',',
          },
        },
        StoredAsSubDirectories: false,
        Parameters: {
          'skip.header.line.count': '1',
        },
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

});

test('unpartitioned JSON table', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  const table = new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.UNENCRYPTED);

  Template.fromStack(tableStack).hasResource('AWS::S3::Bucket', {
    Type: 'AWS::S3::Bucket',
    DeletionPolicy: 'Retain',
    UpdateReplacePolicy: 'Retain',
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('partitioned JSON table', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  const table = new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    partitionKeys: [{
      name: 'year',
      type: glue.Schema.SMALL_INT,
    }],
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.UNENCRYPTED);
  expect(table.encryptionKey).toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      PartitionKeys: [
        {
          Name: 'year',
          Type: 'smallint',
        },
      ],
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('compressed table', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    compressed: true,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryptionKey).toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: true,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('table.node.defaultChild', () => {
  // GIVEN
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  // WHEN
  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    compressed: true,
    dataFormat: glue.DataFormat.json(),
  });

  // THEN
  expect(table.node.defaultChild instanceof CfnTable).toEqual(true);
});

test('encrypted table: SSE-S3', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.S3_MANAGED,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.S3_MANAGED);
  expect(table.encryptionKey).toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });

  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {
    BucketEncryption: {
      ServerSideEncryptionConfiguration: [
        {
          ServerSideEncryptionByDefault: {
            SSEAlgorithm: 'AES256',
          },
        },
      ],
    },
  });
});

test('encrypted table: SSE-KMS (implicitly created key)', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.KMS,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.KMS);
  expect(table.encryptionKey).toEqual(table.bucket.encryptionKey);

  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
    Description: 'Created by Default/Table/Bucket',
  });

  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {
    BucketEncryption: {
      ServerSideEncryptionConfiguration: [
        {
          ServerSideEncryptionByDefault: {
            KMSMasterKeyID: {
              'Fn::GetAtt': [
                'TableBucketKey3E9F984A',
                'Arn',
              ],
            },
            SSEAlgorithm: 'aws:kms',
          },
        },
      ],
    },
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('encrypted table: SSE-KMS (explicitly created key)', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });
  const encryptionKey = new kms.Key(stack, 'MyKey', {
    description: 'OurKey',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.KMS,
    encryptionKey,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.KMS);
  expect(table.encryptionKey).toEqual(table.bucket.encryptionKey);
  expect(table.encryptionKey).not.toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
    Description: 'OurKey',
  });

  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {
    BucketEncryption: {
      ServerSideEncryptionConfiguration: [
        {
          ServerSideEncryptionByDefault: {
            KMSMasterKeyID: {
              'Fn::GetAtt': [
                'MyKey6AB29FA6',
                'Arn',
              ],
            },
            SSEAlgorithm: 'aws:kms',
          },
        },
      ],
    },
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('encrypted table: SSE-KMS_MANAGED', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.KMS_MANAGED,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.KMS_MANAGED);
  expect(table.encryptionKey).toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::S3::Bucket', {
    BucketEncryption: {
      ServerSideEncryptionConfiguration: [
        {
          ServerSideEncryptionByDefault: {
            SSEAlgorithm: 'aws:kms',
          },
        },
      ],
    },
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('encrypted table: CSE-KMS (implicitly created key)', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);
  expect(table.encryptionKey).not.toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).resourceCountIs('AWS::KMS::Key', 1);

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('encrypted table: CSE-KMS (explicitly created key)', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });
  const encryptionKey = new kms.Key(stack, 'MyKey', {
    description: 'MyKey',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,
    encryptionKey,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);
  expect(table.encryptionKey).not.toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
    Description: 'MyKey',
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'TableBucketDA42407C',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('encrypted table: CSE-KMS (explicitly passed bucket and key)', () => {
  const stack = new cdk.Stack();
  const database = new glue.Database(stack, 'Database', {
    databaseName: 'database',
  });
  const bucket = new s3.Bucket(stack, 'Bucket');
  const encryptionKey = new kms.Key(stack, 'MyKey', {
    description: 'MyKey',
  });

  const table = new glue.Table(stack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    bucket,
    encryption: glue.TableEncryption.CLIENT_SIDE_KMS,
    encryptionKey,
    dataFormat: glue.DataFormat.json(),
  });
  expect(table.encryption).toEqual(glue.TableEncryption.CLIENT_SIDE_KMS);
  expect(table.encryptionKey).not.toEqual(undefined);
  expect(table.bucket.encryptionKey).toEqual(undefined);

  Template.fromStack(stack).hasResourceProperties('AWS::KMS::Key', {
    Description: 'MyKey',
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      Ref: 'DatabaseB269D8BB',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: true,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'Bucket83908E77',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('explicit s3 bucket and prefix', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const stack = new cdk.Stack(app, 'app');
  const bucket = new s3.Bucket(stack, 'ExplicitBucket');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  new glue.Table(stack, 'Table', {
    database,
    bucket,
    s3Prefix: 'prefix/',
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.json(),
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'ExplicitBucket0AA51A3F',
              },
              '/prefix/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

test('explicit s3 bucket and with empty prefix', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const stack = new cdk.Stack(app, 'app');
  const bucket = new s3.Bucket(stack, 'ExplicitBucket');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  new glue.Table(stack, 'Table', {
    database,
    bucket,
    s3Prefix: '',
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    dataFormat: glue.DataFormat.json(),
  });

  Template.fromStack(stack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Description: 'table generated by CDK',
      Name: 'table',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      StorageDescriptor: {
        Columns: [
          {
            Name: 'col',
            Type: 'string',
          },
        ],
        Compressed: false,
        InputFormat: 'org.apache.hadoop.mapred.TextInputFormat',
        Location: {
          'Fn::Join': [
            '',
            [
              's3://',
              {
                Ref: 'ExplicitBucket0AA51A3F',
              },
              '/',
            ],
          ],
        },
        OutputFormat: 'org.apache.hadoop.hive.ql.io.HiveIgnoreKeyTextOutputFormat',
        SerdeInfo: {
          SerializationLibrary: 'org.openx.data.jsonserde.JsonSerDe',
        },
        StoredAsSubDirectories: false,
      },
      TableType: 'EXTERNAL_TABLE',
    },
  });
});

describe('add partition index', () => {
  test('fails if no partition keys', () => {
    const stack = new cdk.Stack();
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      dataFormat: glue.DataFormat.json(),
    });

    expect(() => table.addPartitionIndex({
      indexName: 'my-part',
      keyNames: ['part'],
    })).toThrowError(/The table must have partition keys to create a partition index/);
  });

  test('fails if partition index does not match partition keys', () => {
    const stack = new cdk.Stack();
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      partitionKeys: [{
        name: 'part',
        type: glue.Schema.SMALL_INT,
      }],
      dataFormat: glue.DataFormat.json(),
    });

    expect(() => table.addPartitionIndex({
      indexName: 'my-part',
      keyNames: ['not-part'],
    })).toThrowError(/All index keys must also be partition keys/);
  });

  test('fails with index name < 1 character', () => {
    const stack = new cdk.Stack();
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      partitionKeys: [{
        name: 'part',
        type: glue.Schema.SMALL_INT,
      }],
      dataFormat: glue.DataFormat.json(),
    });

    expect(() => table.addPartitionIndex({
      indexName: '',
      keyNames: ['part'],
    })).toThrowError(/Index name must be between 1 and 255 characters, but got 0/);
  });

  test('fails with > 3 indexes', () => {
    const stack = new cdk.Stack();
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const indexes: PartitionIndex[] = [{
      indexName: 'ind1',
      keyNames: ['part'],
    }, {
      indexName: 'ind2',
      keyNames: ['part'],
    }, {
      indexName: 'ind3',
      keyNames: ['part'],
    }, {
      indexName: 'ind4',
      keyNames: ['part'],
    }];

    expect(() => new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      partitionKeys: [{
        name: 'part',
        type: glue.Schema.SMALL_INT,
      }],
      partitionIndexes: indexes,
      dataFormat: glue.DataFormat.json(),
    })).toThrowError('Maximum number of partition indexes allowed is 3');
  });
});

describe('grants', () => {
  test('custom permissions', () => {
    const stack = new cdk.Stack();
    const user = new iam.User(stack, 'User');
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      compressed: true,
      dataFormat: glue.DataFormat.json(),
    });

    table.grant(user, ['glue:UpdateTable']);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: 'glue:UpdateTable',
            Effect: 'Allow',
            Resource: {
              'Fn::Join': [
                '',
                [
                  'arn:',
                  {
                    Ref: 'AWS::Partition',
                  },
                  ':glue:',
                  {
                    Ref: 'AWS::Region',
                  },
                  ':',
                  {
                    Ref: 'AWS::AccountId',
                  },
                  ':table/',
                  {
                    Ref: 'DatabaseB269D8BB',
                  },
                  '/',
                  {
                    Ref: 'Table4C2D914F',
                  },
                ],
              ],
            },
          },
        ],
        Version: '2012-10-17',
      },
      PolicyName: 'UserDefaultPolicy1F97781E',
      Users: [
        {
          Ref: 'User00B015A1',
        },
      ],
    });
  });

  test('read only', () => {
    const stack = new cdk.Stack();
    const user = new iam.User(stack, 'User');
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      compressed: true,
      dataFormat: glue.DataFormat.json(),
    });

    table.grantRead(user);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: [
              'glue:BatchGetPartition',
              'glue:GetPartition',
              'glue:GetPartitions',
              'glue:GetTable',
              'glue:GetTables',
              'glue:GetTableVersion',
              'glue:GetTableVersions',
            ],
            Effect: 'Allow',
            Resource: {
              'Fn::Join': [
                '',
                [
                  'arn:',
                  {
                    Ref: 'AWS::Partition',
                  },
                  ':glue:',
                  {
                    Ref: 'AWS::Region',
                  },
                  ':',
                  {
                    Ref: 'AWS::AccountId',
                  },
                  ':table/',
                  {
                    Ref: 'DatabaseB269D8BB',
                  },
                  '/',
                  {
                    Ref: 'Table4C2D914F',
                  },
                ],
              ],
            },
          },
          {
            Action: [
              's3:GetObject*',
              's3:GetBucket*',
              's3:List*',
            ],
            Effect: 'Allow',
            Resource: [
              {
                'Fn::GetAtt': [
                  'TableBucketDA42407C',
                  'Arn',
                ],
              },
              {
                'Fn::Join': [
                  '',
                  [
                    {
                      'Fn::GetAtt': [
                        'TableBucketDA42407C',
                        'Arn',
                      ],
                    },
                    '/*',
                  ],
                ],
              },
            ],
          },
        ],
        Version: '2012-10-17',
      },
      PolicyName: 'UserDefaultPolicy1F97781E',
      Users: [
        {
          Ref: 'User00B015A1',
        },
      ],
    });
  });

  test('write only', () => {
    const stack = new cdk.Stack();
    const user = new iam.User(stack, 'User');
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      compressed: true,
      dataFormat: glue.DataFormat.json(),
    });

    table.grantWrite(user);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: [
              'glue:BatchCreatePartition',
              'glue:BatchDeletePartition',
              'glue:CreatePartition',
              'glue:DeletePartition',
              'glue:UpdatePartition',
            ],
            Effect: 'Allow',
            Resource: {
              'Fn::Join': [
                '',
                [
                  'arn:',
                  {
                    Ref: 'AWS::Partition',
                  },
                  ':glue:',
                  {
                    Ref: 'AWS::Region',
                  },
                  ':',
                  {
                    Ref: 'AWS::AccountId',
                  },
                  ':table/',
                  {
                    Ref: 'DatabaseB269D8BB',
                  },
                  '/',
                  {
                    Ref: 'Table4C2D914F',
                  },
                ],
              ],
            },
          },
          {
            Action: [
              's3:DeleteObject*',
              's3:PutObject',
              's3:PutObjectLegalHold',
              's3:PutObjectRetention',
              's3:PutObjectTagging',
              's3:PutObjectVersionTagging',
              's3:Abort*',
            ],
            Effect: 'Allow',
            Resource: [
              {
                'Fn::GetAtt': [
                  'TableBucketDA42407C',
                  'Arn',
                ],
              },
              {
                'Fn::Join': [
                  '',
                  [
                    {
                      'Fn::GetAtt': [
                        'TableBucketDA42407C',
                        'Arn',
                      ],
                    },
                    '/*',
                  ],
                ],
              },
            ],
          },
        ],
        Version: '2012-10-17',
      },
      PolicyName: 'UserDefaultPolicy1F97781E',
      Users: [
        {
          Ref: 'User00B015A1',
        },
      ],
    });
  });

  test('read and write', () => {
    const stack = new cdk.Stack();
    const user = new iam.User(stack, 'User');
    const database = new glue.Database(stack, 'Database', {
      databaseName: 'database',
    });

    const table = new glue.Table(stack, 'Table', {
      database,
      tableName: 'table',
      columns: [{
        name: 'col',
        type: glue.Schema.STRING,
      }],
      compressed: true,
      dataFormat: glue.DataFormat.json(),
    });

    table.grantReadWrite(user);

    Template.fromStack(stack).hasResourceProperties('AWS::IAM::Policy', {
      PolicyDocument: {
        Statement: [
          {
            Action: [
              'glue:BatchGetPartition',
              'glue:GetPartition',
              'glue:GetPartitions',
              'glue:GetTable',
              'glue:GetTables',
              'glue:GetTableVersion',
              'glue:GetTableVersions',
              'glue:BatchCreatePartition',
              'glue:BatchDeletePartition',
              'glue:CreatePartition',
              'glue:DeletePartition',
              'glue:UpdatePartition',
            ],
            Effect: 'Allow',
            Resource: {
              'Fn::Join': [
                '',
                [
                  'arn:',
                  {
                    Ref: 'AWS::Partition',
                  },
                  ':glue:',
                  {
                    Ref: 'AWS::Region',
                  },
                  ':',
                  {
                    Ref: 'AWS::AccountId',
                  },
                  ':table/',
                  {
                    Ref: 'DatabaseB269D8BB',
                  },
                  '/',
                  {
                    Ref: 'Table4C2D914F',
                  },
                ],
              ],
            },
          },
          {
            Action: [
              's3:GetObject*',
              's3:GetBucket*',
              's3:List*',
              's3:DeleteObject*',
              's3:PutObject',
              's3:PutObjectLegalHold',
              's3:PutObjectRetention',
              's3:PutObjectTagging',
              's3:PutObjectVersionTagging',
              's3:Abort*',
            ],
            Effect: 'Allow',
            Resource: [
              {
                'Fn::GetAtt': [
                  'TableBucketDA42407C',
                  'Arn',
                ],
              },
              {
                'Fn::Join': [
                  '',
                  [
                    {
                      'Fn::GetAtt': [
                        'TableBucketDA42407C',
                        'Arn',
                      ],
                    },
                    '/*',
                  ],
                ],
              },
            ],
          },
        ],
        Version: '2012-10-17',
      },
      PolicyName: 'UserDefaultPolicy1F97781E',
      Users: [
        {
          Ref: 'User00B015A1',
        },
      ],
    });
  });
});

describe('validate', () => {
  test('at least one column', () => {
    expect(() => {
      createTable({
        columns: [],
        tableName: 'name',
      });
    }).toThrowError('you must specify at least one column for the table');

  });

  test('unique column names', () => {
    expect(() => {
      createTable({
        tableName: 'name',
        columns: [{
          name: 'col1',
          type: glue.Schema.STRING,
        }, {
          name: 'col1',
          type: glue.Schema.STRING,
        }],
      });
    }).toThrowError("column names and partition keys must be unique, but 'col1' is duplicated");

  });

  test('unique partition keys', () => {
    expect(() => {
      createTable({
        tableName: 'name',
        columns: [{
          name: 'col1',
          type: glue.Schema.STRING,
        }],
        partitionKeys: [{
          name: 'p1',
          type: glue.Schema.STRING,
        }, {
          name: 'p1',
          type: glue.Schema.STRING,
        }],
      });
    }).toThrowError("column names and partition keys must be unique, but 'p1' is duplicated");

  });

  test('column names and partition keys are all unique', () => {
    expect(() => {
      createTable({
        tableName: 'name',
        columns: [{
          name: 'col1',
          type: glue.Schema.STRING,
        }],
        partitionKeys: [{
          name: 'col1',
          type: glue.Schema.STRING,
        }],
      });
    }).toThrowError("column names and partition keys must be unique, but 'col1' is duplicated");

  });

  test('can not specify an explicit bucket and encryption', () => {
    expect(() => {
      createTable({
        tableName: 'name',
        columns: [{
          name: 'col1',
          type: glue.Schema.STRING,
        }],
        bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),
        encryption: glue.TableEncryption.KMS,
      });
    }).toThrowError('you can not specify encryption settings if you also provide a bucket');
  });

  test('can explicitly pass bucket if Encryption undefined', () => {
    expect(() => createTable({
      tableName: 'name',
      columns: [{
        name: 'col1',
        type: glue.Schema.STRING,
      }],
      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),
      encryption: undefined,
    })).not.toThrow();
  });

  test('can explicitly pass bucket if Unencrypted', () => {
    expect(() => createTable({
      tableName: 'name',
      columns: [{
        name: 'col1',
        type: glue.Schema.STRING,
      }],
      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),
      encryption: undefined,
    })).not.toThrow();
  });

  test('can explicitly pass bucket if ClientSideKms', () => {
    expect(() => createTable({
      tableName: 'name',
      columns: [{
        name: 'col1',
        type: glue.Schema.STRING,
      }],
      bucket: new s3.Bucket(new cdk.Stack(), 'Bucket'),
      encryption: glue.TableEncryption.CLIENT_SIDE_KMS,
    })).not.toThrow();
  });
});

test('Table.fromTableArn', () => {
  // GIVEN
  const stack = new cdk.Stack();

  // WHEN
  const table = glue.Table.fromTableArn(stack, 'boom', 'arn:aws:glue:us-east-1:123456789012:table/db1/tbl1');

  // THEN
  expect(table.tableArn).toEqual('arn:aws:glue:us-east-1:123456789012:table/db1/tbl1');
  expect(table.tableName).toEqual('tbl1');
});

test.each([
  ['enabled', true],
  ['disabled', false],
])('Partition filtering on table %s', (_, enabled) => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    partitionKeys: [{
      name: 'year',
      type: glue.Schema.SMALL_INT,
    }],
    dataFormat: glue.DataFormat.json(),
    enablePartitionFiltering: enabled,
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        'classification': 'json',
        'has_encrypted_data': false,
        'partition_filtering.enabled': enabled,
      },
      PartitionKeys: Match.anyValue(),
      StorageDescriptor: Match.anyValue(),
      TableType: Match.anyValue(),
    },
  });
});

test('Partition filtering on table is not defined (default behavior)', () => {
  const app = new cdk.App();
  const dbStack = new cdk.Stack(app, 'db');
  const database = new glue.Database(dbStack, 'Database', {
    databaseName: 'database',
  });

  const tableStack = new cdk.Stack(app, 'table');
  new glue.Table(tableStack, 'Table', {
    database,
    tableName: 'table',
    columns: [{
      name: 'col',
      type: glue.Schema.STRING,
    }],
    partitionKeys: [{
      name: 'year',
      type: glue.Schema.SMALL_INT,
    }],
    dataFormat: glue.DataFormat.json(),
    enablePartitionFiltering: undefined,
  });

  Template.fromStack(tableStack).hasResourceProperties('AWS::Glue::Table', {
    CatalogId: {
      Ref: 'AWS::AccountId',
    },
    DatabaseName: {
      'Fn::ImportValue': 'db:ExportsOutputRefDatabaseB269D8BB88F4B1C4',
    },
    TableInput: {
      Name: 'table',
      Description: 'table generated by CDK',
      Parameters: {
        classification: 'json',
        has_encrypted_data: false,
      },
      PartitionKeys: Match.anyValue(),
      StorageDescriptor: Match.anyValue(),
      TableType: Match.anyValue(),
    },
  });
});

function createTable(props: Pick<glue.TableProps, Exclude<keyof glue.TableProps, 'database' | 'dataFormat'>>): void {
  const stack = new cdk.Stack();
  new glue.Table(stack, 'table', {
    ...props,
    database: new glue.Database(stack, 'db', {
      databaseName: 'database_name',
    }),
    dataFormat: glue.DataFormat.json(),
  });
}
