import { IOpenIdConnectProvider, ISamlProvider, IRole } from '@aws-cdk/aws-iam';
import { IFunction } from '@aws-cdk/aws-lambda';
import { Resource, IResource, Stack, ArnFormat, Lazy, Names } from '@aws-cdk/core';
import { Construct } from 'constructs';
import { CfnIdentityPool, CfnIdentityPoolRoleAttachment } from './cognito.generated';
import { IUserPool } from './user-pool';
import { IUserPoolClient, UserPoolClient, UserPoolClientOptions } from './user-pool-client';

/**
 * Represents a Cognito IdentityPool
 */
export interface IIdentityPool extends IResource {
  /**
   * The id of the Identity Pool in the format REGION:GUID
   * @attribute
   */
  readonly identityPoolId: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  readonly identityPoolArn: string;

  /**
   * Name of the Identity Pool
   * @attribute
   */
  readonly identityPoolName: string
}

/**
 * Props for the IdentityPool construct
 */
export interface IdentityPoolProps {

  /**
   * The name of the Identity Pool
   * @default - automatically generated name by CloudFormation at deploy time
   */
  readonly identityPoolName?: string;

  /**
   * The Default Role to be assumed by Authenticated Users
   */
  readonly authenticatedRole: IRole;

  /**
   * The Default Role to be assumed by Unauthenticated Users
   */
  readonly unauthenticatedRole: IRole;

  /**
   * The Default Role to be assumed by Authenticated Users
   * @default - no Role Mappings
   */
  readonly roleMappings?: IdentityPoolRoleMapping[];

  /**
   * The User Pools associated with this Identity Pool
   * @default - no User Pools Associated
   */
  readonly userPools?: IUserPool[];

  /**
   * The OpenIdConnect Provider associated with this Identity Pool
   * @default - no OpenIdConnectProvider
   */
  readonly openIdConnectProviders?: IOpenIdConnectProvider[];

  /**
   * The Security Assertion Markup Language Provider associated with this Identity Pool
   * @default - no SamlProvider
   */
  readonly samlProviders?: ISamlProvider[];

  /**
   * The Developer Provider Name to associate with this Identity Pool
   * @default - no Custom Provider
   */
  readonly customProvider?: string;

  /**
   * Whether to allow unauthenticated identities access to identity pool
   * @default false
   */
  readonly allowUnauthenticatedIdentities?: boolean;

  /**
   * The User Pool Client Options to apply to User Pool Clients configured by the provided User Pools
   * @default {}
   */
  readonly defaultClientOptions?: UserPoolClientOptions;

  /**
   * Setting this to true turns off identity pool checks with the integrated user pools to make sure the user has not been globally signed out or deleted before the identity pool provides an OIDC token or AWS credentials for the user
   * @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-cognito-identitypool-cognitoidentityprovider.html
   * @default false
   */
  readonly disableServerSideTokenCheck?: boolean;

  /**
   * Enables the Basic (Classic) authentication flow
   * @default - Classic Flow not allowed
   */
  readonly allowClassicFlow?: boolean;

  /**
   * The configuration options to be applied to the identity pool.
   * @default - No push sync config
   */
  readonly pushSyncConfig?: PushSyncConfig;

  /**
   * The configuration options for Amazon Cognito streams.
   * @default - No Cognito stream options
   */
  readonly streamOptions?: CognitoStreamOptions;

  /**
   * Set a lambda function to respond to events in Amazon Cognito
   *  @see https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-events.html
   * @default - No Sync Triggers
   */
  readonly syncTrigger?: IFunction;

  /**
   * Supported login providers for using directly in identity pool without using OpnIdConnect or a user pool.
   * @default - No Supported Login Providers passed directly to Identity Pool
   */
  readonly supportedLoginProviders?: SupportedLoginProviders
}

/**
 * The configuration options for Amazon Cognito streams.
 */
export interface CognitoStreamOptions {

  /**
   * The name of the Amazon Cognito stream to receive updates
   * @default - Automatically generated by CloudFormation
   */
  readonly streamName?: string;
  /**
   * Whether the Amazon Cognito Streams are enabled
   * @default false
   */
  readonly enableStreamingStatus?: boolean;

  /**
   * The role Amazon Cognito can assume to publish to the stream. This role must grant access to Amazon Cognito (cognito-sync) to invoke PutRecord on your Amazon Cognito stream.
   * @default - No role set for Cognito Streams
   */
  readonly role?: IRole;
}

/**
 * The configuration options to be applied to the identity pool.
 */
export interface PushSyncConfig {
  /**
   * The ARNs of the Amazon SNS platform applications that could be used by clients.
   * @default []
   */
  readonly applicationArns?: string[]

  /**
   * An IAM role configured to allow Amazon Cognito to call Amazon SNS on behalf of the developer.
   * @default - No role set for Push Sync
   */
  readonly role?: IRole
}

/**
 * Map roles to users in the identity pool based on claims from the Identity Provider
 *  @see https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-identitypoolroleattachment.html
 */
export interface IdentityPoolRoleMapping {
  /**
   * The url of the provider of for which the role is mapped
   */
  readonly providerUrl: SupportedLoginProviderType | string;

  /**
   *  If true then mapped roles must be passed through the cognito:roles or cognito:preferred_role claims from identity provider.
   * @see https://docs.aws.amazon.com/cognito/latest/developerguide/role-based-access-control.html#using-tokens-to-assign-roles-to-users
   *
   * @default false
   */
  readonly useToken?: boolean;

  /**
   * Allow for role assumption when results of role mapping are ambiguous
   * @default false - Ambiguous role resolutions will lead to requester being denied
   */
  readonly resolveAmbiguousRoles?: boolean;

  /**
   * The claim and value that must be matched in order to assume the role. Required if useToken is false
   * @default - No Rule Mapping Rule
   */
  readonly rules?: RoleMappingRule[];

}

/**
 * Types of matches allowed for Role Mapping
 */
export enum RoleMappingMatchType {
  /**
   * The Claim from the token must equal the given value in order for a match
   */
  EQUALS = 'Equals',

  /**
   * The Claim from the token must contain the given value in order for a match
   */
  CONTAINS = 'Contains',

  /**
   * The Claim from the token must start with the given value in order for a match
   */
  STARTS_WITH = 'StartsWith',

  /**
   * The Claim from the token must not equal the given value in order for a match
   */
  NOTEQUAL = 'NotEqual',
}

/**
 * Represents an Identity Pool Role Attachment Role Mapping Rule
 */
export interface RoleMappingRule {
  /**
   * The key sent in the token by the federated identity provider.
   */
  readonly claim: string;

  /**
    * The Role to be assumed when Claim Value is matched.
    */
  readonly mappedRole: IRole;

  /**
    * The value of the claim that must be matched
    */
  readonly claimValue: string;

  /**
   * How to match with the Claim value
   * @default RoleMappingMatchType.EQUALS
   */
  readonly matchType?: RoleMappingMatchType
}

/**
 * Keys for SupportedLoginProvider - correspond to client id's of respective federation identity providers
 */
export enum SupportedLoginProviderType {
  /** Facebook Provider type */
  FACEBOOK = 'graph.facebook.com',
  /** Google Provider Type */
  GOOGLE = 'accounts.google.com',
  /** Amazon Provider Type */
  AMAZON = 'www.amazon.com',
  /** Apple Provider Type */
  APPLE = 'appleid.apple.com',
  /** Twitter Provider Type */
  TWITTER = 'api.twitter.com'
}

/**
 * Supported login providers for using directly in identity pool without using OpenIdConnect or a user pool. String values are id's associated with provider. Separate multiple fields with a semicolon
 * @see https://docs.aws.amazon.com/cognito/latest/developerguide/external-identity-providers.html
 */
export interface SupportedLoginProviders {
  /** Id for Facebook Identity Federation
   * @default - No Facebook Login Provider used without OpenIdConnect or a User Pool
  */
  readonly facebook?: string

  /** Id for Google Identity Federation
   * @default - No Google Login Provider used without OpenIdConnect or a User Pool
  */
  readonly google?: string

  /** Id for Facebook Identity Federation
   * @default -  No Amazon Login Provider used without OpenIdConnect or a User Pool
  */
  readonly amazon?: string

  /** Id for Apple Identity Federation
   * @default - No Apple Login Provider used without OpenIdConnect or a User Pool
  */
  readonly apple?: string

  /** Id and Secret separated by a semicolon for Twitter Identity Federation
   * @default - No Twitter Login Provider used without OpenIdConnect or a User Pool
  */
  readonly twitter?: string
}

/**
 * Define a Cognito Identity Pool
 */
export class IdentityPool extends Resource implements IIdentityPool {

  /**
   * Import an existing Identity Pool from its id
   */
  public static fromIdentityPoolId(scope: Construct, id: string, identityPoolId: string): IIdentityPool {
    const identityPoolArn = Stack.of(scope).formatArn({
      service: 'cognito-identity',
      resource: 'identitypool',
      resourceName: identityPoolId,
      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
    });

    return IdentityPool.fromIdentityPoolArn(scope, id, identityPoolArn);
  }

  /**
   * Import an existing Identity Pool from its Arn
   */
  public static fromIdentityPoolArn(scope: Construct, id: string, identityPoolArn: string): IIdentityPool {
    const pool = Stack.of(scope).splitArn(identityPoolArn, ArnFormat.SLASH_RESOURCE_NAME);
    const res = pool.resourceName || '';
    if (!res) {
      throw new Error('Invalid Identity Pool ARN');
    }
    const idParts = res.split(':');
    if (!(idParts.length === 2)) throw new Error('Invalid Identity Pool Id: Identity Pool Ids must follow the format <region>:<id>');
    if (idParts[0] !== pool.region) throw new Error('Invalid Identity Pool Id: Region in Identity Pool Id must match stack region');
    class ImportedIdentityPool extends Resource implements IIdentityPool {
      public readonly identityPoolId = res;
      public readonly identityPoolArn = identityPoolArn;
      public readonly identityPoolName: string
      constructor() {
        super(scope, id, {
          account: pool.account,
          region: pool.region,
        });
        this.identityPoolName = this.physicalName;
      }
    }
    return new ImportedIdentityPool();
  }

  /**
   * The id of the Identity Pool in the format REGION:GUID
   * @attribute
   */
  public readonly identityPoolId: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  public readonly identityPoolArn: string;

  /**
   * The ARN of the Identity Pool
   * @attribute
   */
  public readonly identityPoolName: string;

  /**
   * The Identity Pool Cloud Formation Construct
   */
  private cfnIdentityPool: CfnIdentityPool;

  /**
   * List of Identity Providers added in constructor for use with property overrides
   */
  private cognitoIdentityProviders: CfnIdentityPool.CognitoIdentityProviderProperty[] = []

  constructor(scope: Construct, private id: string, props:IdentityPoolProps) {
    super(scope, id, {
      physicalName: props.identityPoolName || Lazy.string({ produce: () => this.node.uniqueId }),
    });
    this.identityPoolName = this.physicalName;
    const providers = this.configureUserPools(props);
    if (providers && providers.length) this.cognitoIdentityProviders = providers;

    this.cfnIdentityPool = new CfnIdentityPool(this, id, {
      allowUnauthenticatedIdentities: props.allowUnauthenticatedIdentities ? true : false,
      allowClassicFlow: props.allowClassicFlow,
      identityPoolName: props.identityPoolName,
      developerProviderName: props.customProvider,
      openIdConnectProviderArns: this.configureOpenIdConnectProviderArns(props.openIdConnectProviders),
      samlProviderArns: this.configureSamlProviderArns(props.samlProviders),
      cognitoEvents: this.configureCognitoEvents(props.syncTrigger),
      cognitoStreams: this.configureCognitoStreamOptions(props.streamOptions),
      pushSync: this.configurePushSyncConfig(props.pushSyncConfig),
      supportedLoginProviders: this.configureSupportedLoginProviders(props.supportedLoginProviders),
      cognitoIdentityProviders: providers,
    });
    this.identityPoolId = this.cfnIdentityPool.ref;
    this.identityPoolArn = Stack.of(scope).formatArn({
      service: 'cognito-identity',
      resource: 'identitypool',
      resourceName: this.identityPoolId,
      arnFormat: ArnFormat.SLASH_RESOURCE_NAME,
    });

    this.configureRoleAttachment(props.authenticatedRole, props.unauthenticatedRole, ...(props.roleMappings || []));
  }

  /**
   * Add a User Pool to the IdentityPool and configures User Pool Client to handle identities
   */
  public addUserPool(userPool: IUserPool, options?: UserPoolClientOptions, disableServerSideTokenCheck?: boolean): UserPoolClient {
    const client = this.configureUserPoolClient(userPool, options);
    this.cognitoIdentityProviders = this.cognitoIdentityProviders
      .concat(this.configureIdentityProviders(userPool, client, disableServerSideTokenCheck));
    const providers = this.cognitoIdentityProviders.map(provider => {
      return {
        ClientId: provider.clientId,
        ProviderName: provider.providerName,
        ServerSideTokenCheck: provider.serverSideTokenCheck,
      };
    }, this);
    this.cfnIdentityPool.addPropertyOverride('CognitoIdentityProviders', providers);
    return client;
  }

  /**
   * Adds Role Mappings to Identity Pool
  */
  public addRoleMappings(...mappings: IdentityPoolRoleMapping[]): void {
    if (!mappings || !mappings.length) return;
    const name = this.id + 'RoleAttachment-' + this.generateRandomName();
    const roleMappings = this.configureRoleMappings(...mappings);

    const attachment = new CfnIdentityPoolRoleAttachment(this, name, {
      identityPoolId: this.identityPoolId,
      roleMappings,
    });
    attachment.node.addDependency(this.cfnIdentityPool);
  }

  /**
   * Configure Role Attachments For Identity Pool
   */
  private configureRoleAttachment(
    authenticatedRole?: IRole,
    unauthenticatedRole?: IRole,
    ...mappings: IdentityPoolRoleMapping[]
  ): void {
    const name = this.id + 'RoleAttachment-' + this.generateRandomName();
    let roles: any = undefined, roleMappings: any = undefined;
    if (authenticatedRole || unauthenticatedRole) {
      roles = {};
      if (authenticatedRole) roles.authenticated = authenticatedRole.roleArn;
      if (unauthenticatedRole) roles.unauthenticated = unauthenticatedRole.roleArn;
    }
    if (mappings) {
      roleMappings = this.configureRoleMappings(...mappings);
    }
    const attachment = new CfnIdentityPoolRoleAttachment(this, name, {
      identityPoolId: this.identityPoolId,
      roles,
      roleMappings,
    });
    attachment.node.addDependency(this.cfnIdentityPool);
  }

  /**
   * Configure CognitoIdentityProviders for a User Pools
   */
  private configureIdentityProviders(
    userPool: IUserPool,
    client: IUserPoolClient,
    disableServerSideTokenCheck?: boolean,
  ): CfnIdentityPool.CognitoIdentityProviderProperty[] {
    return userPool.identityProviders.map(provider => {
      return {
        clientId: client.userPoolClientId,
        providerName: provider.providerName,
        serverSideTokenCheck: disableServerSideTokenCheck ? false : true,
      };
    });
  }

  /**
   * Configures and returns new User Pool Client that will implement Identity Providers in Identity Pool
   */
  private configureUserPoolClient(userPool: IUserPool, options?: UserPoolClientOptions): UserPoolClient {
    return userPool.addClient('UserPoolClientFor' + options?.userPoolClientName || this.generateRandomName(), options);
  }

  /**
   * Configure CognitoIdentityProviders from list of User Pools
   */
  private configureUserPools(props: IdentityPoolProps): CfnIdentityPool.CognitoIdentityProviderProperty[] | undefined {
    if (!props.userPools) return undefined;
    let providers: CfnIdentityPool.CognitoIdentityProviderProperty[] = [];
    props.userPools.forEach(pool => {
      const client = this.configureUserPoolClient(pool, props.defaultClientOptions);
      providers = [...providers, ...this.configureIdentityProviders(pool, client, props.disableServerSideTokenCheck)];
    }, this);
    return providers;
  }

  /**
   * Converts OpenIdConnectProvider constructs to an array of Arns
   */
  private configureOpenIdConnectProviderArns(arns: IOpenIdConnectProvider[] = []): string[] | undefined {
    let arnList = arns.map(openId => openId.openIdConnectProviderArn);
    if (!arnList.length) return undefined;
    return arnList;
  }

  /**
   * Converts SamlProvider constructs to an array of Arns
   */
  private configureSamlProviderArns(arns: ISamlProvider[] = []): string[] | undefined {
    let arnList = arns.map(saml => saml.samlProviderArn);
    if (!arnList.length) return undefined;
    return arnList;
  }

  /**
   * Converts SyncTrigger lambda into a Cognito Event
   */
  private configureCognitoEvents(syncTrigger?: IFunction): any {
    if (!syncTrigger) return undefined;
    return {
      SyncTrigger: syncTrigger.functionArn,
    };
  }

  /**
   * Converts CognitoStreamOptions into CfnIdentityPool.CognitoStreamProperty
   */
  private configureCognitoStreamOptions(options?: CognitoStreamOptions): CfnIdentityPool.CognitoStreamsProperty | undefined {
    if (!options) return undefined;
    const property: any = {
      roleArn: options.role ? options.role.roleArn : undefined,
      streamName: options.streamName,
    };

    if (options.hasOwnProperty('enableStreamingStatus')) {
      property.streamingStatus = options.enableStreamingStatus ? 'ENABLED' : 'DISABLED';
    }
    return property as CfnIdentityPool.CognitoStreamsProperty;
  }

  /**
   * Converts PushSyncConfig into CfnIdentityPool.PushSyncProperty
   */
  private configurePushSyncConfig(config?: PushSyncConfig): CfnIdentityPool.PushSyncProperty | undefined {
    if (!config) return undefined;
    return {
      roleArn: config.role ? config.role.roleArn : undefined,
      applicationArns: config.applicationArns,
    };
  }

  /**
   * Formats supported login providers
   */
  private configureSupportedLoginProviders(providers?: SupportedLoginProviders): any {
    if (!providers) return undefined;
    const supportedProviders:any = {};
    if (providers.amazon) supportedProviders[SupportedLoginProviderType.AMAZON] = providers.amazon;
    if (providers.facebook) supportedProviders[SupportedLoginProviderType.FACEBOOK] = providers.facebook;
    if (providers.google) supportedProviders[SupportedLoginProviderType.GOOGLE] = providers.google;
    if (providers.apple) supportedProviders[SupportedLoginProviderType.APPLE] = providers.apple;
    if (providers.twitter) supportedProviders[SupportedLoginProviderType.TWITTER] = providers.twitter;
    return supportedProviders;
  }

  /**
   * Configures Role Mappings for Identity Pool Role Attachment
   */
  private configureRoleMappings(
    ...props: IdentityPoolRoleMapping[]
  ): { [name:string]: CfnIdentityPoolRoleAttachment.RoleMappingProperty } | undefined {
    if (!props || !props.length) return undefined;
    return props.reduce((acc, prop) => {
      let roleMapping: any = {
        ambiguousRoleResolution: prop.resolveAmbiguousRoles ? 'AuthenticatedRole' : 'Deny',
        type: prop.useToken ? 'Token' : 'Rules',
        identityProvider: prop.providerUrl,
      };
      if (roleMapping.type === 'Rules') {
        if (!prop.rules) {
          throw new Error('IdentityPoolRoleMapping.rules is required when useToken is false');
        }

        roleMapping.rulesConfiguration = {
          rules: prop.rules.map(rule => {
            return {
              claim: rule.claim,
              value: rule.claimValue,
              matchType: rule.matchType || RoleMappingMatchType.EQUALS,
              roleArn: rule.mappedRole.roleArn,
            };
          }),
        };
      };
      acc[prop.providerUrl] = roleMapping;
      return acc;
    }, {} as { [name:string]: CfnIdentityPoolRoleAttachment.RoleMappingProperty });
  }

  /** Generate random name when construct name is not present */
  private generateRandomName(): string {
    const name = Names.uniqueId(this);
    if (name.length > 20) {
      return name.substring(0, 20);
    }
    return name;
  }
}