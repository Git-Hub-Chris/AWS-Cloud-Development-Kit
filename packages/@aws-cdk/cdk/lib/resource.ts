import { ArnComponents } from './arn';
import { Construct, IConstruct } from './construct';
import { Lazy } from './lazy';
import { PhysicalName } from './physical-name';
import { CrossEnvironmentAttribute as CrossEnvironmentAttribute } from './private/cross-environment-token';
import { generatePhysicalName } from './private/physical-name-generator';
import { Stack } from './stack';
import { Token } from './token';

/**
 * Interface for the Resource construct.
 */
export interface IResource extends IConstruct {
  /**
   * The stack in which this resource is defined.
   */
  readonly stack: Stack;
}

/**
 * Construction properties for {@link Resource}.
 */
export interface ResourceProps {
  /**
   * The physical (that is, visible in the AWS Console) name of this resource.
   * By default, the name will be automatically generated by CloudFormation, at
   * deploy time.
   *
   * @default - The physical name will be allocated by CloudFormation at deployment time
   */
  readonly physicalName?: string;
}

/**
 * A construct which represents an AWS resource.
 */
export abstract class Resource extends Construct implements IResource {
  public readonly stack: Stack;

  /**
   * Returns a string-encoded token that resolves to the physical name that should be
   * passed to the CloudFormation resource.
   *
   * This token will resolve to one of:
   * - a concrete value
   * - `undefined`, when a name should be generated by cloudformation
   * - a name generated automatically during synthesis, in cross-account scenario.
   *
   * @experimental
   */
  protected readonly physicalName: string;

  private _physicalName: string | undefined;
  private readonly _allowCrossEnvironment: boolean;

  constructor(scope: Construct, id: string, props: ResourceProps = {}) {
    super(scope, id);
    this.stack = Stack.of(this);

    let physicalName = props.physicalName;

    if (props.physicalName === PhysicalName.GENERATE_IF_NEEDED) {
      // auto-generate only if cross-env is required
      this._physicalName = undefined;
      this._allowCrossEnvironment = true;
      physicalName = Lazy.stringValue({ produce: () => this._physicalName });
    } else if (!Token.isUnresolved(props.physicalName)) {
      // concrete value specified by the user
      this._physicalName = props.physicalName;
      this._allowCrossEnvironment = true;
    } else {
      // either undefined (deploy-time) or has tokens, which means we can't use for cross-env
      this._physicalName = props.physicalName;
      this._allowCrossEnvironment = false;
    }

    if (physicalName === undefined) {
      physicalName = Token.asString(undefined);
    }

    this.physicalName = physicalName;
  }

  /**
   * Called when this resource is referenced across environments (account/region) to order to
   * request that a physical name will be generated for this resource during synthesis, so the
   * resource can be referenced through it's absolute name/arn.
   *
   * @internal
   */
  public _enableCrossEnvironment(): void {
    if (!this._allowCrossEnvironment) {
      // error out - a deploy-time name cannot be used across environments
      throw new Error(`Cannot use resource '${this.node.path}' in a cross-environment fashion, ` +
        "the resource's physical name must be explicit set or use PhysicalName.GENERATE_IF_NEEDED");
    }

    if (!this._physicalName) {
      this._physicalName = generatePhysicalName(this);
    }
  }

  /**
   * @experimental
   */
  protected getCrossEnvironmentAttributes(recipe: CrossEnvironmentRecipe): CrossEnvironmentAttributes {
    return {
      name: this.getResourceNameAttribute(recipe.name),
      arn: this.getResourceArnAttribute(recipe.arn, recipe.arnComponents)
    };
  }

  /**
   * @experimental
   */
  protected getResourceNameAttribute(nameAttr: string) {
    return Token.asString(new CrossEnvironmentAttribute(nameAttr, this.physicalName, this));
  }

  /**
   * @experimental
   */
  protected getResourceArnAttribute(arnAttr: string, arnComponents: ArnComponents) {
    return Token.asString(new CrossEnvironmentAttribute(arnAttr, this.stack.formatArn(arnComponents), this));
  }
}

/**
 * Construction properties for {@link ResourceIdentifiers}.
 *
 * @experimental
 */
export interface CrossEnvironmentRecipe {
  /**
   * The ARN of the resource when referenced from the same stack.
   */
  readonly arn: string;

  /**
   * The name of the resource when referenced from the same stack.
   */
  readonly name: string;

  /**
   * The recipe for creating an ARN from a name for this resource.
   */
  readonly arnComponents: ArnComponents;
}

/**
 * The identifiers (name and ARN) for a given L2.
 * These should be only used inside the Construct Library implementation.
 *
 * @experimental
 */
export interface CrossEnvironmentAttributes {
  readonly arn: string;
  readonly name: string;
}
