"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mockSpawn = void 0;
const child_process = require("child_process");
const events = require("events");
if (!child_process.spawn.mockImplementationOnce) {
    throw new Error('Call "jest.mock(\'child_process\');" at the top of the test file!');
}
function mockSpawn(...invocations) {
    let mock = child_process.spawn;
    for (const _invocation of invocations) {
        const invocation = _invocation; // Mirror into variable for closure
        mock = mock.mockImplementationOnce((binary, args, options) => {
            if (invocation.prefix) {
                // Match command line prefix
                expect([binary, ...args].slice(0, invocation.commandLine.length)).toEqual(invocation.commandLine);
            }
            else {
                // Match full command line
                expect([binary, ...args]).toEqual(invocation.commandLine);
            }
            if (invocation.cwd != null) {
                expect(options.cwd).toBe(invocation.cwd);
            }
            const child = new events.EventEmitter();
            child.stdin = new events.EventEmitter();
            child.stdin.write = jest.fn();
            child.stdin.end = jest.fn();
            child.stdout = new events.EventEmitter();
            child.stderr = new events.EventEmitter();
            if (invocation.stdout) {
                mockEmit(child.stdout, 'data', Buffer.from(invocation.stdout));
            }
            mockEmit(child, 'close', invocation.exitCode ?? 0);
            return child;
        });
    }
    mock.mockImplementation((binary, args, _options) => {
        throw new Error(`Did not expect call of ${JSON.stringify([binary, ...args])}`);
    });
    return () => {
        expect(mock).toHaveBeenCalledTimes(invocations.length);
    };
}
exports.mockSpawn = mockSpawn;
/**
 * Must do this on the next tick, as emitter.emit() expects all listeners to have been attached already
 */
function mockEmit(emitter, event, data) {
    setImmediate(() => {
        emitter.emit(event, data);
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9jay1jaGlsZF9wcm9jZXNzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibW9jay1jaGlsZF9wcm9jZXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtDQUErQztBQUMvQyxpQ0FBaUM7QUFFakMsSUFBSSxDQUFFLGFBQXFCLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFLENBQUM7SUFDekQsTUFBTSxJQUFJLEtBQUssQ0FBQyxtRUFBbUUsQ0FBQyxDQUFDO0FBQ3ZGLENBQUM7QUFjRCxTQUFnQixTQUFTLENBQUMsR0FBRyxXQUF5QjtJQUNwRCxJQUFJLElBQUksR0FBSSxhQUFhLENBQUMsS0FBYSxDQUFDO0lBQ3hDLEtBQUssTUFBTSxXQUFXLElBQUksV0FBVyxFQUFFLENBQUM7UUFDdEMsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLENBQUMsbUNBQW1DO1FBQ25FLElBQUksR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsQ0FBQyxNQUFjLEVBQUUsSUFBYyxFQUFFLE9BQW1DLEVBQUUsRUFBRTtZQUN6RyxJQUFJLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDdEIsNEJBQTRCO2dCQUM1QixNQUFNLENBQUMsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQ3BHLENBQUM7aUJBQU0sQ0FBQztnQkFDTiwwQkFBMEI7Z0JBQzFCLE1BQU0sQ0FBQyxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM1RCxDQUFDO1lBRUQsSUFBSSxVQUFVLENBQUMsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO2dCQUMzQixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDM0MsQ0FBQztZQUVELE1BQU0sS0FBSyxHQUFRLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQzdDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzlCLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztZQUM1QixLQUFLLENBQUMsTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO1lBQ3pDLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFFekMsSUFBSSxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3RCLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ2pFLENBQUM7WUFDRCxRQUFRLENBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRW5ELE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsSUFBSSxDQUFDLGtCQUFrQixDQUFDLENBQUMsTUFBYyxFQUFFLElBQWMsRUFBRSxRQUFhLEVBQUUsRUFBRTtRQUN4RSxNQUFNLElBQUksS0FBSyxDQUFDLDBCQUEwQixJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakYsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLEdBQUcsRUFBRTtRQUNWLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDekQsQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQXhDRCw4QkF3Q0M7QUFFRDs7R0FFRztBQUNILFNBQVMsUUFBUSxDQUFDLE9BQTRCLEVBQUUsS0FBYSxFQUFFLElBQVM7SUFDdEUsWUFBWSxDQUFDLEdBQUcsRUFBRTtRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM1QixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjaGlsZF9wcm9jZXNzIGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZXZlbnRzIGZyb20gJ2V2ZW50cyc7XG5cbmlmICghKGNoaWxkX3Byb2Nlc3MgYXMgYW55KS5zcGF3bi5tb2NrSW1wbGVtZW50YXRpb25PbmNlKSB7XG4gIHRocm93IG5ldyBFcnJvcignQ2FsbCBcImplc3QubW9jayhcXCdjaGlsZF9wcm9jZXNzXFwnKTtcIiBhdCB0aGUgdG9wIG9mIHRoZSB0ZXN0IGZpbGUhJyk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSW52b2NhdGlvbiB7XG4gIGNvbW1hbmRMaW5lOiBzdHJpbmdbXTtcbiAgY3dkPzogc3RyaW5nO1xuICBleGl0Q29kZT86IG51bWJlcjtcbiAgc3Rkb3V0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBPbmx5IG1hdGNoIGEgcHJlZml4IG9mIHRoZSBjb21tYW5kIChkb24ndCBjYXJlIGFib3V0IHRoZSBkZXRhaWxzIG9mIHRoZSBhcmd1bWVudHMpXG4gICAqL1xuICBwcmVmaXg/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbW9ja1NwYXduKC4uLmludm9jYXRpb25zOiBJbnZvY2F0aW9uW10pOiAoKSA9PiB2b2lkIHtcbiAgbGV0IG1vY2sgPSAoY2hpbGRfcHJvY2Vzcy5zcGF3biBhcyBhbnkpO1xuICBmb3IgKGNvbnN0IF9pbnZvY2F0aW9uIG9mIGludm9jYXRpb25zKSB7XG4gICAgY29uc3QgaW52b2NhdGlvbiA9IF9pbnZvY2F0aW9uOyAvLyBNaXJyb3IgaW50byB2YXJpYWJsZSBmb3IgY2xvc3VyZVxuICAgIG1vY2sgPSBtb2NrLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKGJpbmFyeTogc3RyaW5nLCBhcmdzOiBzdHJpbmdbXSwgb3B0aW9uczogY2hpbGRfcHJvY2Vzcy5TcGF3bk9wdGlvbnMpID0+IHtcbiAgICAgIGlmIChpbnZvY2F0aW9uLnByZWZpeCkge1xuICAgICAgICAvLyBNYXRjaCBjb21tYW5kIGxpbmUgcHJlZml4XG4gICAgICAgIGV4cGVjdChbYmluYXJ5LCAuLi5hcmdzXS5zbGljZSgwLCBpbnZvY2F0aW9uLmNvbW1hbmRMaW5lLmxlbmd0aCkpLnRvRXF1YWwoaW52b2NhdGlvbi5jb21tYW5kTGluZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBNYXRjaCBmdWxsIGNvbW1hbmQgbGluZVxuICAgICAgICBleHBlY3QoW2JpbmFyeSwgLi4uYXJnc10pLnRvRXF1YWwoaW52b2NhdGlvbi5jb21tYW5kTGluZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnZvY2F0aW9uLmN3ZCAhPSBudWxsKSB7XG4gICAgICAgIGV4cGVjdChvcHRpb25zLmN3ZCkudG9CZShpbnZvY2F0aW9uLmN3ZCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkOiBhbnkgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkaW4gPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkaW4ud3JpdGUgPSBqZXN0LmZuKCk7XG4gICAgICBjaGlsZC5zdGRpbi5lbmQgPSBqZXN0LmZuKCk7XG4gICAgICBjaGlsZC5zdGRvdXQgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpO1xuICAgICAgY2hpbGQuc3RkZXJyID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKTtcblxuICAgICAgaWYgKGludm9jYXRpb24uc3Rkb3V0KSB7XG4gICAgICAgIG1vY2tFbWl0KGNoaWxkLnN0ZG91dCwgJ2RhdGEnLCBCdWZmZXIuZnJvbShpbnZvY2F0aW9uLnN0ZG91dCkpO1xuICAgICAgfVxuICAgICAgbW9ja0VtaXQoY2hpbGQsICdjbG9zZScsIGludm9jYXRpb24uZXhpdENvZGUgPz8gMCk7XG5cbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9KTtcbiAgfVxuXG4gIG1vY2subW9ja0ltcGxlbWVudGF0aW9uKChiaW5hcnk6IHN0cmluZywgYXJnczogc3RyaW5nW10sIF9vcHRpb25zOiBhbnkpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCBub3QgZXhwZWN0IGNhbGwgb2YgJHtKU09OLnN0cmluZ2lmeShbYmluYXJ5LCAuLi5hcmdzXSl9YCk7XG4gIH0pO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgZXhwZWN0KG1vY2spLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcyhpbnZvY2F0aW9ucy5sZW5ndGgpO1xuICB9O1xufVxuXG4vKipcbiAqIE11c3QgZG8gdGhpcyBvbiB0aGUgbmV4dCB0aWNrLCBhcyBlbWl0dGVyLmVtaXQoKSBleHBlY3RzIGFsbCBsaXN0ZW5lcnMgdG8gaGF2ZSBiZWVuIGF0dGFjaGVkIGFscmVhZHlcbiAqL1xuZnVuY3Rpb24gbW9ja0VtaXQoZW1pdHRlcjogZXZlbnRzLkV2ZW50RW1pdHRlciwgZXZlbnQ6IHN0cmluZywgZGF0YTogYW55KSB7XG4gIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgZW1pdHRlci5lbWl0KGV2ZW50LCBkYXRhKTtcbiAgfSk7XG59XG4iXX0=